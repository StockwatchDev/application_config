{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"application_settings - version develop \"You write the dataclasses to define parameters for configuration and settings, application_settings takes care of the logic.\" What and why Application_settings is a package for providing a python application or library with parameters for configuration and settings. It uses toml or json files that are parsed into dataclasses. This brings some benefits: Minimal work for the developer of the application / library Parameters are typed, which allows for improved static code analyses. IDEs will provide helpful hints and completion when using the parameters. More control over what happens when a file contains mistakes (by leveraging the power of pydantic ). Possibility to specify defaults when no file is found or entries are missing. Configuration parameters are read-only (i.e., changed by editing the config file); we recommend (and support) the use of toml for this, which is a human-oriented, flexible, standardardized and not overly complex format. Settings parameters are read-write (i.e., mostly changed via the UI of the application); we recommend (and support) use json for this, an established standardized machine-oriented format. Parsing is done once before or during first access and the resulting set of parameters is stored as a singleton. Interested? Then have a look at our quick start . License This project is licensed under the terms of the MIT license.","title":"Home"},{"location":"#application_settings-version-develop","text":"\"You write the dataclasses to define parameters for configuration and settings, application_settings takes care of the logic.\"","title":"application_settings - version develop"},{"location":"#what-and-why","text":"Application_settings is a package for providing a python application or library with parameters for configuration and settings. It uses toml or json files that are parsed into dataclasses. This brings some benefits: Minimal work for the developer of the application / library Parameters are typed, which allows for improved static code analyses. IDEs will provide helpful hints and completion when using the parameters. More control over what happens when a file contains mistakes (by leveraging the power of pydantic ). Possibility to specify defaults when no file is found or entries are missing. Configuration parameters are read-only (i.e., changed by editing the config file); we recommend (and support) the use of toml for this, which is a human-oriented, flexible, standardardized and not overly complex format. Settings parameters are read-write (i.e., mostly changed via the UI of the application); we recommend (and support) use json for this, an established standardized machine-oriented format. Parsing is done once before or during first access and the resulting set of parameters is stored as a singleton. Interested? Then have a look at our quick start .","title":"What and why"},{"location":"#license","text":"This project is licensed under the terms of the MIT license.","title":"License"},{"location":"CHANGELOG/","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . [Unreleased] - 2023-xx-yy Added Multiple versions of documentation served on Github Pages. You can now request a (re-) load when setting the filepath or via a method load . You can choose whether or not to throw a FileNotFoundError during load when the parameter file is not found in the expected location (Issue #51 ) Support for parameters in the main container (Issue #20 ). Support for subsections (arbitrary depth) (Issue #5 ). Sections also stored as a singleton, so that libs can define and access parameters via their own Section (Issue #46 ). Literal SectionTypeStr exported. Convenience functions to specify filepath for config and settings via command line [ #53 ] Changed The method update now is a class method (breaking). You cannot request a reload via method get anymore, use separate method load (breaking). A Container now is a specialization of a ContainerSection. Fixed Default folder name no longer just a dot if container class is called Config or Settings. [0.2.0] - 2023-03-19 Added Files can be formatted as toml or json . Introduced settings, i.e., read-write parameters (where config is read-only). Now also useable with python 3.9. Documentation extended and served on Github Pages. Changed File path for config / settings now via set_filepath() and no longer as argument of get() . [0.1.0] - 2023-02-13 Added Loading a toml file. Initializing a dataclass with the loaded toml and storing it as a singleton. Default path, folder and file name. Specification of a config file path via argument of get() . Validation using pydantic. README that explains it all.","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"CHANGELOG/#unreleased-2023-xx-yy","text":"","title":"[Unreleased] - 2023-xx-yy"},{"location":"CHANGELOG/#added","text":"Multiple versions of documentation served on Github Pages. You can now request a (re-) load when setting the filepath or via a method load . You can choose whether or not to throw a FileNotFoundError during load when the parameter file is not found in the expected location (Issue #51 ) Support for parameters in the main container (Issue #20 ). Support for subsections (arbitrary depth) (Issue #5 ). Sections also stored as a singleton, so that libs can define and access parameters via their own Section (Issue #46 ). Literal SectionTypeStr exported. Convenience functions to specify filepath for config and settings via command line [ #53 ]","title":"Added"},{"location":"CHANGELOG/#changed","text":"The method update now is a class method (breaking). You cannot request a reload via method get anymore, use separate method load (breaking). A Container now is a specialization of a ContainerSection.","title":"Changed"},{"location":"CHANGELOG/#fixed","text":"Default folder name no longer just a dot if container class is called Config or Settings.","title":"Fixed"},{"location":"CHANGELOG/#020-2023-03-19","text":"","title":"[0.2.0] - 2023-03-19"},{"location":"CHANGELOG/#added_1","text":"Files can be formatted as toml or json . Introduced settings, i.e., read-write parameters (where config is read-only). Now also useable with python 3.9. Documentation extended and served on Github Pages.","title":"Added"},{"location":"CHANGELOG/#changed_1","text":"File path for config / settings now via set_filepath() and no longer as argument of get() .","title":"Changed"},{"location":"CHANGELOG/#010-2023-02-13","text":"","title":"[0.1.0] - 2023-02-13"},{"location":"CHANGELOG/#added_2","text":"Loading a toml file. Initializing a dataclass with the loaded toml and storing it as a singleton. Default path, folder and file name. Specification of a config file path via argument of get() . Validation using pydantic. README that explains it all.","title":"Added"},{"location":"CODE_OF_CONDUCT/","text":"Contributor Covenant Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at stockwatchdevs@gmail.com. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Contributor Covenant Code of Conduct"},{"location":"CODE_OF_CONDUCT/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"CODE_OF_CONDUCT/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"CODE_OF_CONDUCT/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"CODE_OF_CONDUCT/#scope","text":"This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"CODE_OF_CONDUCT/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at stockwatchdevs@gmail.com. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"CODE_OF_CONDUCT/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"docs/1-Installation/","text":"Install the package application_settings is available for pypi and can hence be installed with pip or poetry . The package is not available on conda . If you don't want to wait for a release and prefer to try the develop version, then you can install from our repo. Windows Linux # From pypi with pip: py - m pip install - U application_settings # From pypi with poetry: poetry add application_settings # From the repo with pip: py - m pip install git + https : // github . com / StockwatchDev / application_settings #develop # From the repo with poetry: poetry add git + https : // github . com / StockwatchDev / application_settings #develop # From pypi: python - m pip install - U application_settings # From pypi with poetry: poetry add application_settings # From the repo with pip: python - m pip install git + https : // github . com / StockwatchDev / application_settings #develop # From the repo with poetry: poetry add git + https : // github . com / StockwatchDev / application_settings #develop We have direct dependencies on the following packages: pathvalidate pydantic tomli (for python versions below 3.11) tomli-w typing-extensions (for python versions below 3.11)","title":"1. Installation"},{"location":"docs/1-Installation/#install-the-package","text":"application_settings is available for pypi and can hence be installed with pip or poetry . The package is not available on conda . If you don't want to wait for a release and prefer to try the develop version, then you can install from our repo. Windows Linux # From pypi with pip: py - m pip install - U application_settings # From pypi with poetry: poetry add application_settings # From the repo with pip: py - m pip install git + https : // github . com / StockwatchDev / application_settings #develop # From the repo with poetry: poetry add git + https : // github . com / StockwatchDev / application_settings #develop # From pypi: python - m pip install - U application_settings # From pypi with poetry: poetry add application_settings # From the repo with pip: python - m pip install git + https : // github . com / StockwatchDev / application_settings #develop # From the repo with poetry: poetry add git + https : // github . com / StockwatchDev / application_settings #develop We have direct dependencies on the following packages: pathvalidate pydantic tomli (for python versions below 3.11) tomli-w typing-extensions (for python versions below 3.11)","title":"Install the package"},{"location":"docs/2-Defining_parameters/","text":"This package lets you define parameters for configuration and settings. The difference between configuration and settings is as follows. Config is for parameters that do not change during runtime and are read from file. Settings are parameters that can change programmatically during runtime and are read from and saved to file for persistancy over sessions. During definition, they differ only in terms of the base classes that are used. The intended structure is that parameters are defined in section classes. Sections can be nested. There should be one special root section for the application, referred to as the container, that handles file storage. Config sections and Settings sections should never be mixed (i.e., do not nest a Settings section in a Config section and vice versa). Defining non-container section(s) A section is defined by subclassing the relevant base class (ConfigSectionBase for config, SettingsSectionBase for settings) and decorating it with @dataclass(frozen=True) . Parameters are defined as fields of the dataclass. For a dataclass, it is mandatory to add a type hint for each field. These type hints are used also to validate the data that is read from the parameter file (because we are using pydantic dataclasses ). If you specify a default value as well, then you prevent the occurance of an exception if the value for the parameter of concern is not found in the parameter file. Nested sections are obtained by defining fields in a section that are type hinted with the appropriate contained section class(es) and instantiated (possible only when all parameters of the nested section have default values). Defining the container The container is a special section that is to be the root for parametrisation of an application. It is defined likewise: by subclassing the relevant base class (ConfigBase for config, SettingsBase for settings), decorating it with @dataclass(frozen=True) , defining fields for parameters and nested non-root sections. Note that albeit settings can be changed programmatically, we still set frozen=True for the settings container and -sections (see also the example section below). Example Configuration Settings from pydantic.dataclasses import dataclass from application_settings import ConfigBase , ConfigSectionBase @dataclass ( frozen = True ) class MyExampleConfigSection ( ConfigSectionBase ): \"\"\"Config section for an example\"\"\" field1 : float = 0.5 field2 : int = 2 @dataclass ( frozen = True ) class MyExampleConfig ( ConfigBase ): \"\"\"Config for an example\"\"\" name : str = \"nice example\" section1 : MyExampleConfigSection = MyExampleConfigSection () from pydantic.dataclasses import dataclass from application_settings import SettingsBase , SettingsSectionBase @dataclass ( frozen = True ) class BasicSettingsSection ( SettingsSectionBase ): \"\"\"Settings section for the basics\"\"\" totals : int = 2 @dataclass ( frozen = True ) class MyExampleSettings ( SettingsBase ): \"\"\"Settings for an example\"\"\" name : str = \"nice name\" basics : BasicSettingsSection = BasicSettingsSection ()","title":"2. Defining parameters"},{"location":"docs/2-Defining_parameters/#defining-non-container-sections","text":"A section is defined by subclassing the relevant base class (ConfigSectionBase for config, SettingsSectionBase for settings) and decorating it with @dataclass(frozen=True) . Parameters are defined as fields of the dataclass. For a dataclass, it is mandatory to add a type hint for each field. These type hints are used also to validate the data that is read from the parameter file (because we are using pydantic dataclasses ). If you specify a default value as well, then you prevent the occurance of an exception if the value for the parameter of concern is not found in the parameter file. Nested sections are obtained by defining fields in a section that are type hinted with the appropriate contained section class(es) and instantiated (possible only when all parameters of the nested section have default values).","title":"Defining non-container section(s)"},{"location":"docs/2-Defining_parameters/#defining-the-container","text":"The container is a special section that is to be the root for parametrisation of an application. It is defined likewise: by subclassing the relevant base class (ConfigBase for config, SettingsBase for settings), decorating it with @dataclass(frozen=True) , defining fields for parameters and nested non-root sections. Note that albeit settings can be changed programmatically, we still set frozen=True for the settings container and -sections (see also the example section below).","title":"Defining the container"},{"location":"docs/2-Defining_parameters/#example","text":"Configuration Settings from pydantic.dataclasses import dataclass from application_settings import ConfigBase , ConfigSectionBase @dataclass ( frozen = True ) class MyExampleConfigSection ( ConfigSectionBase ): \"\"\"Config section for an example\"\"\" field1 : float = 0.5 field2 : int = 2 @dataclass ( frozen = True ) class MyExampleConfig ( ConfigBase ): \"\"\"Config for an example\"\"\" name : str = \"nice example\" section1 : MyExampleConfigSection = MyExampleConfigSection () from pydantic.dataclasses import dataclass from application_settings import SettingsBase , SettingsSectionBase @dataclass ( frozen = True ) class BasicSettingsSection ( SettingsSectionBase ): \"\"\"Settings section for the basics\"\"\" totals : int = 2 @dataclass ( frozen = True ) class MyExampleSettings ( SettingsBase ): \"\"\"Settings for an example\"\"\" name : str = \"nice name\" basics : BasicSettingsSection = BasicSettingsSection ()","title":"Example"},{"location":"docs/3-Files/","text":"Files for storing parameters A Container class defines a root section and provides for behavior to load parameter values from files and, in case of settings, store updated values to files. Currently, two formats are supported for persistent storage of parameters: toml and json . The toml format is human-oriented, flexible, standardardized and not overly complex. It supports comments, and hence parameters can be easily documented in a toml file. However, when parameters are initialized by reading from a toml file, then changed (because it concerns settings) and subsequently written to file again for persistance, the comments will be lost. Therefore, it does not make much sense to add documenting comments to a settings file. Because config parameters are read-only, comments in a config file will not get lost and do make sense. Because of this, the default format for storing config parameters is toml . The name of a config file equals config.toml by default. JSON is a standardized, lightweight data-interchange format that is easy for machines to parse and generate. It is a bit less straightforward to document parameters in this format, which makes it less human-oriented than toml , but it is used widely for data interchange between automated systems. Because of this, the default format for storing settings parameters is json . The name of a settings file equals settings.json by default. The examples introduced in the previous chapter can for example be initialized with the following files. config.toml file for the configuration example settings.json file for the settings example # Use this file to set the config that you prefer by editing the file name = \"application specific name\" [section1] # field1 has default value 0.5 field1 = -0 .5 # field2 has default value 2 field2 = 22 { \"name\" : \"the stored name\" , \"basics\" : { \"totals\" : 3 } } The field names of a Container class are found as: the root parameter names and the section names in the toml file the member names of the root object in the json file The field names of a Section class are found as: the parameter names inside the corresponding section in the toml file the member names of the object that is the value of the name that represents the section in the json file The order of sections and/or fields in the file does not have to adhere to the order in which fields have been specified in the Container - or Section classes. Presence of sections and/or fields in the files that are not defined in the classes goes by silently. Fields or complete sections defined in the classes can be absent in the files as long as default values have been specified for all fields that have been left out. For more info on data validation click here Location, name and type of the file By default, the config and settings files are located in a subfolder of the home folder of the user running the application. The default name of that subfolder is provided by the default_foldername() method and consists of a dot, followed by a name derived from your container class: the word Config / Settings is removed, underscores are put in front of capitals (except for the first letter) and all letters are made lower case. For example, the Container class MyExampleConfig by default will store its config in ~/.my_example/config.toml . And MyExampleSettings will default to a settings file ~/.my_example/settings.json . If you want the files to be stored in a different location and/or have a different name and/or change the format, then you can use the method set_filepath . If you invoke this method but you have already instantiated the parameters via load() or get() , then you most likely want to reload them. You can do so by setting an argument load=True in set_filepath . If you invoke this function after parameters have been instantiated and do not set load=True , then a warning is printed. Example: # the next statement sets the location, name and format of the settings file # the argument can be eiter a string or a Path MyExampleSettings . set_filepath ( r \"C:\\ProgramData\\testsettings.toml\" ) # the next statement loads the settings MyExampleSettings . load () # the next statement sets a new name for the settings file and reloads it MyExampleSettings . set_filepath ( r \"C:\\ProgramData\\productionsettings.toml\" , load = True ) # the next statement resets the filepath to the default, doesn't load but generates a warning MyExampleSettings . set_filepath ( \"\" ) The extension of the file is used to select the format for parsing and hence has to be either json , JSON , toml or TOML . Setting the filepath via command-line arguments A quite common scenario is to launch an application from the command-line and to specify the config file and/or settings file as argument(s). Convenience functions are available to support this using the argparse module from the standard library: a function config_filepath_from_cli is available that will define a command-line argument that takes exactly one additional argument, namely the config filepath. You have to specify the Config class when calling this function, and you may pass a parser (default: the main argument parser) and your own short option (default: \"-c\" ) and long option (default: \"--config_filepath\" ) and you may set load=True (default: False ). If the option is indeed supplied when the application is launched, then the config filepath is set using set_filepath and the value for load is passed into this function. a function settings_filepath_from_cli is available that will define a command-line argument that takes exactly one additional argument, namely the settings filepath. You have to specify the Settings class when calling this function, and you may pass a parser (default: the main argument parser) and your own short option (default: \"-s\" ) and long option (default: \"--settings_filepath\" ) and you may set load=True (default: False ). If the option is indeed supplied when the application is launched, then the config filepath is set using set_filepath and the value for load is passed into this function. a function parameters_folderpath_from_cli is also available and comes in handy when you have a config file and a settings file in the same folder. This function will define a command-line argument that takes exactly one additional argument, namely the path of the folder that holds both files. Note that this implies that the config- and settings file have to have the default filename. You have to specify both the Settings class and the Config class when calling this function, and you may pass a parser (default: the main argument parser) and your own short option (default: \"-p\" ) and long option (default: \"--parameters_folderpath\" ) and you may set load=True (default: False ). If the option is indeed supplied when the application is launched, then the config and the settings filepath are set using set_filepath and the value for load is passed into these functions. CLI for config filepath CLI for settings filepath CLI for common config and settings folder from application_settings import config_filepath_from_cli # The next line defines a cli argument \"-c\" and \"--config_filepath\" # and specifies that the config should be loaded when it is specified config_filepath_from_cli ( MyExampleConfig , load = True ) # the application launch with config file spec could be something like: # application_name -c C:\\ProgramData\\productionconfig.toml from application_settings import settings_filepath_from_cli # The next line defines a cli argument \"-s\" and \"--settings_filepath\" # and specifies that the settings should be loaded when it is specified settings_filepath_from_cli ( MyExampleSettings , load = True ) # the application launch with settings file spec could be something like: # application_name -s C:\\ProgramData\\productionsettings.json from application_settings import parameters_folderpath_from_cli # The next line defines a cli argument \"-p\" and \"--parameters_folderpath\" # and specifies that the config and settings should be loaded when it is specified parameters_folderpath_from_cli ( MyExampleConfig , MyExampleSettings , load = True ) # the application launch with folder spec could be something like: # application_name -p C:\\ProgramData Handling FileNotFoundError When loading a parameter file, you have a choice what should happen when the parameter file is not found in the location that has been specified: if you load(throw_if_file_not_found = False) , then the FileNotFoundError is catched by application_settings , an error message is generated and program flow is continued by trying to instantiate the config / settings using default values. If you have defined parameters without default values, a TypeError exception will be raised. if you load(throw_if_file_not_found = True) , then the FileNotFoundError exception is thrown and the application can decide how this situation should be handled. The default value for throw_if_file_not_found is False , hence load() will not throw an exception when the parameter file is not found. Note that if you do not explicitly use load but rather implicitly call it via get() or set_filepath() , then this default behavior will also be obtained.","title":"3. Files and file location"},{"location":"docs/3-Files/#files-for-storing-parameters","text":"A Container class defines a root section and provides for behavior to load parameter values from files and, in case of settings, store updated values to files. Currently, two formats are supported for persistent storage of parameters: toml and json . The toml format is human-oriented, flexible, standardardized and not overly complex. It supports comments, and hence parameters can be easily documented in a toml file. However, when parameters are initialized by reading from a toml file, then changed (because it concerns settings) and subsequently written to file again for persistance, the comments will be lost. Therefore, it does not make much sense to add documenting comments to a settings file. Because config parameters are read-only, comments in a config file will not get lost and do make sense. Because of this, the default format for storing config parameters is toml . The name of a config file equals config.toml by default. JSON is a standardized, lightweight data-interchange format that is easy for machines to parse and generate. It is a bit less straightforward to document parameters in this format, which makes it less human-oriented than toml , but it is used widely for data interchange between automated systems. Because of this, the default format for storing settings parameters is json . The name of a settings file equals settings.json by default. The examples introduced in the previous chapter can for example be initialized with the following files. config.toml file for the configuration example settings.json file for the settings example # Use this file to set the config that you prefer by editing the file name = \"application specific name\" [section1] # field1 has default value 0.5 field1 = -0 .5 # field2 has default value 2 field2 = 22 { \"name\" : \"the stored name\" , \"basics\" : { \"totals\" : 3 } } The field names of a Container class are found as: the root parameter names and the section names in the toml file the member names of the root object in the json file The field names of a Section class are found as: the parameter names inside the corresponding section in the toml file the member names of the object that is the value of the name that represents the section in the json file The order of sections and/or fields in the file does not have to adhere to the order in which fields have been specified in the Container - or Section classes. Presence of sections and/or fields in the files that are not defined in the classes goes by silently. Fields or complete sections defined in the classes can be absent in the files as long as default values have been specified for all fields that have been left out. For more info on data validation click here","title":"Files for storing parameters"},{"location":"docs/3-Files/#location-name-and-type-of-the-file","text":"By default, the config and settings files are located in a subfolder of the home folder of the user running the application. The default name of that subfolder is provided by the default_foldername() method and consists of a dot, followed by a name derived from your container class: the word Config / Settings is removed, underscores are put in front of capitals (except for the first letter) and all letters are made lower case. For example, the Container class MyExampleConfig by default will store its config in ~/.my_example/config.toml . And MyExampleSettings will default to a settings file ~/.my_example/settings.json . If you want the files to be stored in a different location and/or have a different name and/or change the format, then you can use the method set_filepath . If you invoke this method but you have already instantiated the parameters via load() or get() , then you most likely want to reload them. You can do so by setting an argument load=True in set_filepath . If you invoke this function after parameters have been instantiated and do not set load=True , then a warning is printed. Example: # the next statement sets the location, name and format of the settings file # the argument can be eiter a string or a Path MyExampleSettings . set_filepath ( r \"C:\\ProgramData\\testsettings.toml\" ) # the next statement loads the settings MyExampleSettings . load () # the next statement sets a new name for the settings file and reloads it MyExampleSettings . set_filepath ( r \"C:\\ProgramData\\productionsettings.toml\" , load = True ) # the next statement resets the filepath to the default, doesn't load but generates a warning MyExampleSettings . set_filepath ( \"\" ) The extension of the file is used to select the format for parsing and hence has to be either json , JSON , toml or TOML .","title":"Location, name and type of the file"},{"location":"docs/3-Files/#setting-the-filepath-via-command-line-arguments","text":"A quite common scenario is to launch an application from the command-line and to specify the config file and/or settings file as argument(s). Convenience functions are available to support this using the argparse module from the standard library: a function config_filepath_from_cli is available that will define a command-line argument that takes exactly one additional argument, namely the config filepath. You have to specify the Config class when calling this function, and you may pass a parser (default: the main argument parser) and your own short option (default: \"-c\" ) and long option (default: \"--config_filepath\" ) and you may set load=True (default: False ). If the option is indeed supplied when the application is launched, then the config filepath is set using set_filepath and the value for load is passed into this function. a function settings_filepath_from_cli is available that will define a command-line argument that takes exactly one additional argument, namely the settings filepath. You have to specify the Settings class when calling this function, and you may pass a parser (default: the main argument parser) and your own short option (default: \"-s\" ) and long option (default: \"--settings_filepath\" ) and you may set load=True (default: False ). If the option is indeed supplied when the application is launched, then the config filepath is set using set_filepath and the value for load is passed into this function. a function parameters_folderpath_from_cli is also available and comes in handy when you have a config file and a settings file in the same folder. This function will define a command-line argument that takes exactly one additional argument, namely the path of the folder that holds both files. Note that this implies that the config- and settings file have to have the default filename. You have to specify both the Settings class and the Config class when calling this function, and you may pass a parser (default: the main argument parser) and your own short option (default: \"-p\" ) and long option (default: \"--parameters_folderpath\" ) and you may set load=True (default: False ). If the option is indeed supplied when the application is launched, then the config and the settings filepath are set using set_filepath and the value for load is passed into these functions. CLI for config filepath CLI for settings filepath CLI for common config and settings folder from application_settings import config_filepath_from_cli # The next line defines a cli argument \"-c\" and \"--config_filepath\" # and specifies that the config should be loaded when it is specified config_filepath_from_cli ( MyExampleConfig , load = True ) # the application launch with config file spec could be something like: # application_name -c C:\\ProgramData\\productionconfig.toml from application_settings import settings_filepath_from_cli # The next line defines a cli argument \"-s\" and \"--settings_filepath\" # and specifies that the settings should be loaded when it is specified settings_filepath_from_cli ( MyExampleSettings , load = True ) # the application launch with settings file spec could be something like: # application_name -s C:\\ProgramData\\productionsettings.json from application_settings import parameters_folderpath_from_cli # The next line defines a cli argument \"-p\" and \"--parameters_folderpath\" # and specifies that the config and settings should be loaded when it is specified parameters_folderpath_from_cli ( MyExampleConfig , MyExampleSettings , load = True ) # the application launch with folder spec could be something like: # application_name -p C:\\ProgramData","title":"Setting the filepath via command-line arguments"},{"location":"docs/3-Files/#handling-filenotfounderror","text":"When loading a parameter file, you have a choice what should happen when the parameter file is not found in the location that has been specified: if you load(throw_if_file_not_found = False) , then the FileNotFoundError is catched by application_settings , an error message is generated and program flow is continued by trying to instantiate the config / settings using default values. If you have defined parameters without default values, a TypeError exception will be raised. if you load(throw_if_file_not_found = True) , then the FileNotFoundError exception is thrown and the application can decide how this situation should be handled. The default value for throw_if_file_not_found is False , hence load() will not throw an exception when the parameter file is not found. Note that if you do not explicitly use load but rather implicitly call it via get() or set_filepath() , then this default behavior will also be obtained.","title":"Handling FileNotFoundError"},{"location":"docs/4-Using_parameters/","text":"Use parameters in your code Parameter sections and containers are meant to be instantiated just once and be available globally for the application. Therefore, implementation has been done as follows: By in voking method load() on a parameter container class, the container and all contained (nested) sections are instantiated with data values read from the parameter file. The instances are stored for future access in a private module global (a dictionary with the class id as key); The instance of a parameter container or section is accessed via a class method get() ; The parameter value is then obtained by chaining with (the section name(s) and) the parameter name; If a container has not been loaded, the first invocation of get() will do that automatically. This is not the case for a section - if get() is invoked on a section before any loading has been done, it will be instantiated with default values; A parameter container should not be instantiated directly by client code (although it is possible to do so, e.g. for testing purposes); If needed, you can set the path for the parameter file before the first invocation of get() (see chapter on files ). Changing parameter values Parameters are defined as fields of frozen dataclasses. Hence, changing parameter values by means of straightforward assignment will raise an error. Config parameters are meant to be read only. Changing values of such parameters has to be done by editing the config file and restarting your application or reloading the config container. Obviously, settings parameters can also be changed by editing the settings file and restarting the application or reloading the settings container. In addition to that, settings can be changed programmatically by calling a class method update(changes: dict[str, dict[str, Any]) , where the argument changes is a dictionary in which each key is the name of a parameter that is to be updated. For updating a nested section, the key needs to hold the section name and the value should hold a dictionary with str-type keys again, etc. The method update will replace the stored settings in the private module global with an updated instance and the settings file will be updated as well. So the invocation of get() after update or application restart or reloading will return the changed parameter values. Example Configuration Settings import MyExampleConfig # If the config file is not in the default location, then set the path first MyExampleConfig . set_filepath ( r \"C:\\ProgramData\\MyApp\\config.toml\" ) # The next statement will create the config field1_var : str = MyExampleConfig . get () . section1 . field1 # field1_var == -0.5 # The next statement just gets that same instance field2_var : int = MyExampleConfig . get () . section1 . field2 # field2_var == 22 # After edited the config file, you can reload it (which will create a new instance) MyExampleConfig . load () field1_var = MyExampleConfig . get () . section1 . field1 # you cannot programmatically change config parameters import MyExampleSettings # If the settings file is not in the default location, then set the path first MyExampleSettings . set_filepath ( r \"C:\\ProgramData\\MyApp\\settings.json\" ) # The next statement will create the settings name_var : str = MyExampleSettings . get () . name # name_var == \"the stored name\" # The next statement just gets that same instance totals_var : int = MyExampleSettings . get () . basics . totals # totals_var == 3 # After edited the settings file, you can reload it (which will create a new instance) MyExampleSettings . load () name_var = MyExampleSettings . get () . name # change settings parameters programmatically using update MyExampleSettings . update ({ \"name\" : \"updated name\" , \"basics\" : { \"totals\" : 33 }}) print ( MyExampleSettings . get () . name ) # updated name print ( MyExampleSettings . get () . basics . totals ) # 33 # the update has been written to file as well MyExampleSettings . load () print ( MyExampleSettings . get () . name ) # updated name","title":"4. Using parameters"},{"location":"docs/4-Using_parameters/#use-parameters-in-your-code","text":"Parameter sections and containers are meant to be instantiated just once and be available globally for the application. Therefore, implementation has been done as follows: By in voking method load() on a parameter container class, the container and all contained (nested) sections are instantiated with data values read from the parameter file. The instances are stored for future access in a private module global (a dictionary with the class id as key); The instance of a parameter container or section is accessed via a class method get() ; The parameter value is then obtained by chaining with (the section name(s) and) the parameter name; If a container has not been loaded, the first invocation of get() will do that automatically. This is not the case for a section - if get() is invoked on a section before any loading has been done, it will be instantiated with default values; A parameter container should not be instantiated directly by client code (although it is possible to do so, e.g. for testing purposes); If needed, you can set the path for the parameter file before the first invocation of get() (see chapter on files ).","title":"Use parameters in your code"},{"location":"docs/4-Using_parameters/#changing-parameter-values","text":"Parameters are defined as fields of frozen dataclasses. Hence, changing parameter values by means of straightforward assignment will raise an error. Config parameters are meant to be read only. Changing values of such parameters has to be done by editing the config file and restarting your application or reloading the config container. Obviously, settings parameters can also be changed by editing the settings file and restarting the application or reloading the settings container. In addition to that, settings can be changed programmatically by calling a class method update(changes: dict[str, dict[str, Any]) , where the argument changes is a dictionary in which each key is the name of a parameter that is to be updated. For updating a nested section, the key needs to hold the section name and the value should hold a dictionary with str-type keys again, etc. The method update will replace the stored settings in the private module global with an updated instance and the settings file will be updated as well. So the invocation of get() after update or application restart or reloading will return the changed parameter values.","title":"Changing parameter values"},{"location":"docs/4-Using_parameters/#example","text":"Configuration Settings import MyExampleConfig # If the config file is not in the default location, then set the path first MyExampleConfig . set_filepath ( r \"C:\\ProgramData\\MyApp\\config.toml\" ) # The next statement will create the config field1_var : str = MyExampleConfig . get () . section1 . field1 # field1_var == -0.5 # The next statement just gets that same instance field2_var : int = MyExampleConfig . get () . section1 . field2 # field2_var == 22 # After edited the config file, you can reload it (which will create a new instance) MyExampleConfig . load () field1_var = MyExampleConfig . get () . section1 . field1 # you cannot programmatically change config parameters import MyExampleSettings # If the settings file is not in the default location, then set the path first MyExampleSettings . set_filepath ( r \"C:\\ProgramData\\MyApp\\settings.json\" ) # The next statement will create the settings name_var : str = MyExampleSettings . get () . name # name_var == \"the stored name\" # The next statement just gets that same instance totals_var : int = MyExampleSettings . get () . basics . totals # totals_var == 3 # After edited the settings file, you can reload it (which will create a new instance) MyExampleSettings . load () name_var = MyExampleSettings . get () . name # change settings parameters programmatically using update MyExampleSettings . update ({ \"name\" : \"updated name\" , \"basics\" : { \"totals\" : 33 }}) print ( MyExampleSettings . get () . name ) # updated name print ( MyExampleSettings . get () . basics . totals ) # 33 # the update has been written to file as well MyExampleSettings . load () print ( MyExampleSettings . get () . name ) # updated name","title":"Example"},{"location":"docs/5-Usage_in_a_library_package/","text":"You can use application_settings also to parametrize a library package: Define parameters in one or more Section classes (i.e., not in a Container) - best practice is to have a single main section with possibly nested sub-sections; Use parameters in the code of your library by invoking class method get() on your Section class(es) (see chapter on using parameters ); The application that uses your library has to take care of loading stored values into your parameters. This can be done in two ways: If the application also uses application_settings , it's simple; the main Section of your library package just needs to be contained in the Container of the application; If the application does not use application_settings , then the application should invoke class method set(data: dict[str, Any]) on your main Section, where data holds key-value-pairs with the name of the parameter and the value. Subsections can be set by the name of the section as key and a nested dictionary for the subsection parameters. Note that set() should be invoked before any get() is done.","title":"5. Usage in a library package"},{"location":"docs/6-Handling_deviations/","text":"Handling deviations in the parameter file When your parameter file does not adhere to the specified types When loading the parameter file, the values specified are coerced into the appropriate type where possible. If type coercion is not possible, then a pydantic.ValidationError is raised. Consider the case where you would use the following config file for the MyExampleConfig defined before: name = true [section1] field1 = 4 field2 = \"22\" The bool specified for name will be coerced into a str value of \"true\" . The int specified for field1 will be coerced into a float value of 4.0 . The str specified for field2 will be coerced into an int value of 22 . When your parameter file does not contain all specified attributes If your Config or Settings has one of more sections with one or more attributes that do not have a default value, then a parameter file must be loaded and these sections and attributes must be present in the loaded parameter file. If this is not the case, a TypeError is raised. Attributes that have default values can be omitted from the parameter file without problems. Likewise, sections of which all attributes have default values can also be omitted without problems. Note that in the dataclass definitions, attributes without default value have to come before attributes with default values. When your parameter file contains additional, unspecified attributes Entries in a parameter file that are not defined in the Container or Section classes will simply be ignored silently. More advanced typing and validation with pydantic Non-standard types useful for configuration or settings, such as network addresses, are offered, see pydantic types The value of numerous common types can be restricted using pydantic constrained types","title":"6. Handling deviations"},{"location":"docs/6-Handling_deviations/#handling-deviations-in-the-parameter-file","text":"","title":"Handling deviations in the parameter file"},{"location":"docs/6-Handling_deviations/#when-your-parameter-file-does-not-adhere-to-the-specified-types","text":"When loading the parameter file, the values specified are coerced into the appropriate type where possible. If type coercion is not possible, then a pydantic.ValidationError is raised. Consider the case where you would use the following config file for the MyExampleConfig defined before: name = true [section1] field1 = 4 field2 = \"22\" The bool specified for name will be coerced into a str value of \"true\" . The int specified for field1 will be coerced into a float value of 4.0 . The str specified for field2 will be coerced into an int value of 22 .","title":"When your parameter file does not adhere to the specified types"},{"location":"docs/6-Handling_deviations/#when-your-parameter-file-does-not-contain-all-specified-attributes","text":"If your Config or Settings has one of more sections with one or more attributes that do not have a default value, then a parameter file must be loaded and these sections and attributes must be present in the loaded parameter file. If this is not the case, a TypeError is raised. Attributes that have default values can be omitted from the parameter file without problems. Likewise, sections of which all attributes have default values can also be omitted without problems. Note that in the dataclass definitions, attributes without default value have to come before attributes with default values.","title":"When your parameter file does not contain all specified attributes"},{"location":"docs/6-Handling_deviations/#when-your-parameter-file-contains-additional-unspecified-attributes","text":"Entries in a parameter file that are not defined in the Container or Section classes will simply be ignored silently.","title":"When your parameter file contains additional, unspecified attributes"},{"location":"docs/6-Handling_deviations/#more-advanced-typing-and-validation-with-pydantic","text":"Non-standard types useful for configuration or settings, such as network addresses, are offered, see pydantic types The value of numerous common types can be restricted using pydantic constrained types","title":"More advanced typing and validation with pydantic"},{"location":"docs/Quick_start/","text":"Quick start Install the package pip install -U application_settings Define dataclasses for configuration / settings parameters Config is for read-only parameters read from file, Settings are read-write parameters stored to file for persistancy over sessions. During definition, they differ only in terms of the base classes that are used. Example: Configuration Settings from pydantic.dataclasses import dataclass from application_settings import ConfigBase , ConfigSectionBase @dataclass ( frozen = True ) class MyExampleConfigSection ( ConfigSectionBase ): \"\"\"Config section for an example\"\"\" field1 : float = 0.5 field2 : int = 2 @dataclass ( frozen = True ) class MyExampleConfig ( ConfigBase ): \"\"\"Config for an example\"\"\" name : str = \"nice example\" section1 : MyExampleConfigSection = MyExampleConfigSection () from pydantic.dataclasses import dataclass from application_settings import SettingsBase , SettingsSectionBase @dataclass ( frozen = True ) class BasicSettingsSection ( SettingsSectionBase ): \"\"\"Settings section for the basics\"\"\" totals : int = 2 @dataclass ( frozen = True ) class MyExampleSettings ( SettingsBase ): \"\"\"Settings for an example\"\"\" name : str = \"nice name\" basics : BasicSettingsSection = BasicSettingsSection () Write (or generate) the file By default, the following files are expected for the dataclasses defined above: ~/.my_example/config.toml ~/.my_example/settings.json # Use this file to set the config that you prefer by editing the file name = \"the real thing\" [section1] # field1 has default value 0.5 field1 = -0 .5 # field2 has default value 2 field2 = 22 { \"name\" : \"the stored name\" , \"basics\" : { \"totals\" : 3 } } Use parameters in your code Configuration Settings # One of the first things to do in an application is loading the parameters MyExampleConfig . load () # Now you can access parameters via get() # If you get() MyExampleConfig before load(), it will be loaded automatically a_variable = MyExampleConfig . get () . section1 . field1 print ( f \"a_variable == { a_variable } \" ) # a_variable == -0.5 # You can also directly get() a section; but remember that the config should # be loaded already then (get() on a section does not automatically load()) another_variable = MyExampleConfigSection . get () . field2 print ( f \"another_variable == { another_variable } \" ) # another_variable == 22 # The only way to modify a config parameter is by editing the config file # or by changing the default value in the definition # Suppose that we edited the config file, changed the value for name to \"new name\" # and removed field2 # You can reload a config MyExampleConfig . load () new_variable = MyExampleConfig . get () . name print ( f \"new_variable == { new_variable } \" ) # new_variable == \"new name\" another_new_variable = MyExampleConfigSection . get () . field2 print ( f \"another_new_variable == { another_new_variable } \" ) # another_new_variable == 2 # One of the first things to do in an application is loading the parameters MyExampleSettings . load () # Now you can access parameters via get() # If you get() MyExampleSettings before load(), it will be loaded automatically a_variable = MyExampleSettings . get () . name print ( f \"a_variable == ' { a_variable } '\" ) # a_variable == 'the stored name' # You can also directly get() a section; but remember that the settings should # be loaded already then (get() on a section does not automatically load()) another_variable = BasicSettingsSection . get () . totals print ( f \"another_variable == { another_variable } \" ) # another_variable == 3 # You can update the settings: MyExampleSettings . update ({ \"basics\" : { \"totals\" : 33 }}) # The updated values will be written to the settings file automatically and the # singleton is replaced by a new instance of MyExampleSettings with the updated values refreshed_totals = BasicSettingsSection . get () . totals print ( f \"refreshed_totals == { refreshed_totals } \" ) # refreshed_totals == 33 # You can also edit the settings file. Suppose that we changed the value for name to # \"updated name\" # You can reload a setting MyExampleSettings . load () refreshed_name = MyExampleSettings . get () . name print ( f \"refreshed_name == ' { refreshed_name } '\" ) # refreshed_name == 'updated name' These are the basics; a more detailed description is found in the next section (Usage) or you can take a look at the API (Reference).","title":"Quick start"},{"location":"docs/Quick_start/#quick-start","text":"","title":"Quick start"},{"location":"docs/Quick_start/#install-the-package","text":"pip install -U application_settings","title":"Install the package"},{"location":"docs/Quick_start/#define-dataclasses-for-configuration-settings-parameters","text":"Config is for read-only parameters read from file, Settings are read-write parameters stored to file for persistancy over sessions. During definition, they differ only in terms of the base classes that are used. Example: Configuration Settings from pydantic.dataclasses import dataclass from application_settings import ConfigBase , ConfigSectionBase @dataclass ( frozen = True ) class MyExampleConfigSection ( ConfigSectionBase ): \"\"\"Config section for an example\"\"\" field1 : float = 0.5 field2 : int = 2 @dataclass ( frozen = True ) class MyExampleConfig ( ConfigBase ): \"\"\"Config for an example\"\"\" name : str = \"nice example\" section1 : MyExampleConfigSection = MyExampleConfigSection () from pydantic.dataclasses import dataclass from application_settings import SettingsBase , SettingsSectionBase @dataclass ( frozen = True ) class BasicSettingsSection ( SettingsSectionBase ): \"\"\"Settings section for the basics\"\"\" totals : int = 2 @dataclass ( frozen = True ) class MyExampleSettings ( SettingsBase ): \"\"\"Settings for an example\"\"\" name : str = \"nice name\" basics : BasicSettingsSection = BasicSettingsSection ()","title":"Define dataclasses for configuration / settings parameters"},{"location":"docs/Quick_start/#write-or-generate-the-file","text":"By default, the following files are expected for the dataclasses defined above: ~/.my_example/config.toml ~/.my_example/settings.json # Use this file to set the config that you prefer by editing the file name = \"the real thing\" [section1] # field1 has default value 0.5 field1 = -0 .5 # field2 has default value 2 field2 = 22 { \"name\" : \"the stored name\" , \"basics\" : { \"totals\" : 3 } }","title":"Write (or generate) the file"},{"location":"docs/Quick_start/#use-parameters-in-your-code","text":"Configuration Settings # One of the first things to do in an application is loading the parameters MyExampleConfig . load () # Now you can access parameters via get() # If you get() MyExampleConfig before load(), it will be loaded automatically a_variable = MyExampleConfig . get () . section1 . field1 print ( f \"a_variable == { a_variable } \" ) # a_variable == -0.5 # You can also directly get() a section; but remember that the config should # be loaded already then (get() on a section does not automatically load()) another_variable = MyExampleConfigSection . get () . field2 print ( f \"another_variable == { another_variable } \" ) # another_variable == 22 # The only way to modify a config parameter is by editing the config file # or by changing the default value in the definition # Suppose that we edited the config file, changed the value for name to \"new name\" # and removed field2 # You can reload a config MyExampleConfig . load () new_variable = MyExampleConfig . get () . name print ( f \"new_variable == { new_variable } \" ) # new_variable == \"new name\" another_new_variable = MyExampleConfigSection . get () . field2 print ( f \"another_new_variable == { another_new_variable } \" ) # another_new_variable == 2 # One of the first things to do in an application is loading the parameters MyExampleSettings . load () # Now you can access parameters via get() # If you get() MyExampleSettings before load(), it will be loaded automatically a_variable = MyExampleSettings . get () . name print ( f \"a_variable == ' { a_variable } '\" ) # a_variable == 'the stored name' # You can also directly get() a section; but remember that the settings should # be loaded already then (get() on a section does not automatically load()) another_variable = BasicSettingsSection . get () . totals print ( f \"another_variable == { another_variable } \" ) # another_variable == 3 # You can update the settings: MyExampleSettings . update ({ \"basics\" : { \"totals\" : 33 }}) # The updated values will be written to the settings file automatically and the # singleton is replaced by a new instance of MyExampleSettings with the updated values refreshed_totals = BasicSettingsSection . get () . totals print ( f \"refreshed_totals == { refreshed_totals } \" ) # refreshed_totals == 33 # You can also edit the settings file. Suppose that we changed the value for name to # \"updated name\" # You can reload a setting MyExampleSettings . load () refreshed_name = MyExampleSettings . get () . name print ( f \"refreshed_name == ' { refreshed_name } '\" ) # refreshed_name == 'updated name' These are the basics; a more detailed description is found in the next section (Usage) or you can take a look at the API (Reference).","title":"Use parameters in your code"},{"location":"reference/application_settings/","text":"Module application_settings Module for loading and retrieving parameters for configuration and settings. ??? example \"View Source\" \"\"\"Module for loading and retrieving parameters for configuration and settings.\"\"\" from importlib.metadata import version from application_settings.configuring_base import ConfigBase, ConfigSectionBase, ConfigT from application_settings.container_section_base import SectionTypeStr from application_settings.convenience import ( config_filepath_from_cli, parameters_folderpath_from_cli, settings_filepath_from_cli, ) from application_settings.settings_base import ( SettingsBase, SettingsSectionBase, SettingsT, ) from application_settings.type_notation_helper import PathOpt, PathOrStr __version__ = version(\"application_settings\") __all__ = [ \"ConfigSectionBase\", \"ConfigBase\", \"ConfigT\", \"PathOpt\", \"PathOrStr\", \"SectionTypeStr\", \"SettingsSectionBase\", \"SettingsBase\", \"SettingsT\", \"config_filepath_from_cli\", \"settings_filepath_from_cli\", \"parameters_folderpath_from_cli\", ] Sub-modules application_settings.configuring_base application_settings.container_base application_settings.container_section_base application_settings.convenience application_settings.settings_base application_settings.type_notation_helper Variables ConfigT PathOpt PathOrStr SectionTypeStr SettingsT Functions config_filepath_from_cli def config_filepath_from_cli ( config_class : type [ ~ ConfigT ], parser : argparse . ArgumentParser = ArgumentParser ( prog = 'portray' , usage = None , description = None , formatter_class =< class ' argparse . HelpFormatter '>, conflict_handler=' error ', add_help=True), short_option : str = '-c' , long_option : str = '--config_filepath' , load : bool = False ) -> argparse . ArgumentParser Add a commandline option for the config file and set filepath if it is given ??? example \"View Source\" def config_filepath_from_cli( config_class: type[ConfigT], parser: ArgumentParser = ArgumentParser(), short_option: str = \"-c\", long_option: str = \"--config_filepath\", load: bool = False, ) -> ArgumentParser: \"\"\"Add a commandline option for the config file and set filepath if it is given\"\"\" helptext: str = \"Path of the configuration file\" return _parameters_filepath_from_cli( config_class=config_class, settings_class=None, parser=parser, short_option=short_option, long_option=long_option, helptext=helptext, load=load, ) parameters_folderpath_from_cli def parameters_folderpath_from_cli ( config_class : type [ ~ ConfigT ], settings_class : type [ ~ SettingsT ], parser : argparse . ArgumentParser = ArgumentParser ( prog = 'portray' , usage = None , description = None , formatter_class =< class ' argparse . HelpFormatter '>, conflict_handler=' error ', add_help=True), short_option : str = '-p' , long_option : str = '--parameters_folderpath' , load : bool = False ) -> argparse . ArgumentParser Add a commandline option '--parameters_folderpath' for the common config and settings folder and set filepaths if it is given. Default filenames will be appended to the folderpath for config and settings. ??? example \"View Source\" def parameters_folderpath_from_cli( # pylint: disable=too-many-arguments config_class: type[ConfigT], settings_class: type[SettingsT], parser: ArgumentParser = ArgumentParser(), short_option: str = \"-p\", long_option: str = \"--parameters_folderpath\", load: bool = False, ) -> ArgumentParser: \"\"\"Add a commandline option '--parameters_folderpath' for the common config and settings folder and set filepaths if it is given. Default filenames will be appended to the folderpath for config and settings.\"\"\" helptext: str = \"Common path of the config file and settings file\" return _parameters_filepath_from_cli( config_class=config_class, settings_class=settings_class, parser=parser, short_option=short_option, long_option=long_option, helptext=helptext, load=load, ) settings_filepath_from_cli def settings_filepath_from_cli ( settings_class : type [ ~ SettingsT ], parser : argparse . ArgumentParser = ArgumentParser ( prog = 'portray' , usage = None , description = None , formatter_class =< class ' argparse . HelpFormatter '>, conflict_handler=' error ', add_help=True), short_option : str = '-s' , long_option : str = '--settings_filepath' , load : bool = False ) -> argparse . ArgumentParser Add a commandline option for the settings file and set filepath if it is given ??? example \"View Source\" def settings_filepath_from_cli( settings_class: type[SettingsT], parser: ArgumentParser = ArgumentParser(), short_option: str = \"-s\", long_option: str = \"--settings_filepath\", load: bool = False, ) -> ArgumentParser: \"\"\"Add a commandline option for the settings file and set filepath if it is given\"\"\" helptext: str = \"Path of the settings file\" return _parameters_filepath_from_cli( config_class=None, settings_class=settings_class, parser=parser, short_option=short_option, long_option=long_option, helptext=helptext, load=load, ) Classes ConfigBase class ConfigBase ( ) Base class for main Config class ??? example \"View Source\" @dataclass(frozen=True) class ConfigBase(ContainerBase): \"\"\"Base class for main Config class\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Config'\" return \"Config\" @classmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" return FileFormat.TOML @classmethod def update( cls: type[\"ConfigBase\"], changes: dict[str, dict[str, Any]] ) -> \"ConfigBase\": \"Update and save the settings with data specified in changes; not meant for config\" raise TypeError( \"Configs should not be updated runtime; consider converting to settings.\" ) Ancestors (in MRO) application_settings.container_base.ContainerBase application_settings.container_section_base.ContainerSectionBase abc.ABC Static methods default_file_format def default_file_format ( ) -> application_settings . container_base . FileFormat Return the default file format ??? example \"View Source\" @classmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" return FileFormat.TOML default_filename def default_filename ( ) -> str Return the kind_string, lowercase, with the extension that fits the file_format. ??? example \"View Source\" @classmethod def default_filename(cls) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\" default_filepath def default_filepath ( ) -> pathlib . Path | None Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. ??? example \"View Source\" @classmethod def default_filepath(cls) -> PathOpt: \"\"\" Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. \"\"\" return Path.home() / cls.default_foldername() / cls.default_filename() default_foldername def default_foldername ( ) -> str Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words. ??? example \"View Source\" @classmethod def default_foldername(cls) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" if (kind_str := cls.kind_string()) == cls.__name__: return f\".{kind_str.lower()}\" return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() ) filepath def filepath ( ) -> pathlib . Path | None Return the path for the file that holds the config / settings. ??? example \"View Source\" @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath()) get def get ( ) -> Self Get the singleton; if not existing, create it. Reading file only done for a container. ??? example \"View Source\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none kind_string def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Config' ??? example \"View Source\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Config'\" return \"Config\" load def load ( throw_if_file_not_found : bool = False ) -> Self Create a new singleton ??? example \"View Source\" @classmethod def load(cls, throw_if_file_not_found: bool = False) -> Self: \"\"\"Create a new singleton\"\"\" return cls._create_instance(throw_if_file_not_found) set def set ( data : dict [ str , typing . Any ] ) -> Self Create a new dataclass instance using data and set the singleton. ??? example \"View Source\" @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set() set_filepath def set_filepath ( file_path : pathlib . Path | str = '' , load : bool = False ) -> None Set the path for the file (a singleton). ??? example \"View Source\" @classmethod def set_filepath(cls, file_path: PathOrStr = \"\", load: bool = False) -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) if load: cls.load() else: if cls._get() is not None: print( f\"Warning: filepath has been set the but file is not loaded into the {cls.kind_string()}.\" ) update def update ( changes : dict [ str , dict [ str , typing . Any ]] ) -> 'ConfigBase' Update and save the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update( cls: type[\"ConfigBase\"], changes: dict[str, dict[str, Any]] ) -> \"ConfigBase\": \"Update and save the settings with data specified in changes; not meant for config\" raise TypeError( \"Configs should not be updated runtime; consider converting to settings.\" ) ConfigSectionBase class ConfigSectionBase ( ) Base class for all ConfigSection classes (so that we can bound a TypeVar) ??? example \"View Source\" @dataclass(frozen=True) class ConfigSectionBase(ContainerSectionBase): \"\"\"Base class for all ConfigSection classes (so that we can bound a TypeVar)\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Config'\" return \"Config\" Ancestors (in MRO) application_settings.container_section_base.ContainerSectionBase abc.ABC Static methods get def get ( ) -> Self Get the singleton; if not existing, create it. Reading file only done for a container. ??? example \"View Source\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none kind_string def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Config' ??? example \"View Source\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Config'\" return \"Config\" set def set ( data : dict [ str , typing . Any ] ) -> Self Create a new dataclass instance using data and set the singleton. ??? example \"View Source\" @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set() update def update ( changes : dict [ str , typing . Any ] ) -> Self Update the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update(cls, changes: dict[str, Any]) -> Self: \"Update the settings with data specified in changes; not meant for config\" return cls.get()._update(changes)._set() # pylint: disable=protected-access SettingsBase class SettingsBase ( ) Base class for main Settings class ??? example \"View Source\" @dataclass(frozen=True) class SettingsBase(ContainerBase): \"\"\"Base class for main Settings class\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Settings'\" return \"Settings\" @classmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" return FileFormat.JSON Ancestors (in MRO) application_settings.container_base.ContainerBase application_settings.container_section_base.ContainerSectionBase abc.ABC Static methods default_file_format def default_file_format ( ) -> application_settings . container_base . FileFormat Return the default file format ??? example \"View Source\" @classmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" return FileFormat.JSON default_filename def default_filename ( ) -> str Return the kind_string, lowercase, with the extension that fits the file_format. ??? example \"View Source\" @classmethod def default_filename(cls) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\" default_filepath def default_filepath ( ) -> pathlib . Path | None Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. ??? example \"View Source\" @classmethod def default_filepath(cls) -> PathOpt: \"\"\" Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. \"\"\" return Path.home() / cls.default_foldername() / cls.default_filename() default_foldername def default_foldername ( ) -> str Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words. ??? example \"View Source\" @classmethod def default_foldername(cls) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" if (kind_str := cls.kind_string()) == cls.__name__: return f\".{kind_str.lower()}\" return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() ) filepath def filepath ( ) -> pathlib . Path | None Return the path for the file that holds the config / settings. ??? example \"View Source\" @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath()) get def get ( ) -> Self Get the singleton; if not existing, create it. Reading file only done for a container. ??? example \"View Source\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none kind_string def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Settings' ??? example \"View Source\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Settings'\" return \"Settings\" load def load ( throw_if_file_not_found : bool = False ) -> Self Create a new singleton ??? example \"View Source\" @classmethod def load(cls, throw_if_file_not_found: bool = False) -> Self: \"\"\"Create a new singleton\"\"\" return cls._create_instance(throw_if_file_not_found) set def set ( data : dict [ str , typing . Any ] ) -> Self Create a new dataclass instance using data and set the singleton. ??? example \"View Source\" @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set() set_filepath def set_filepath ( file_path : pathlib . Path | str = '' , load : bool = False ) -> None Set the path for the file (a singleton). ??? example \"View Source\" @classmethod def set_filepath(cls, file_path: PathOrStr = \"\", load: bool = False) -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) if load: cls.load() else: if cls._get() is not None: print( f\"Warning: filepath has been set the but file is not loaded into the {cls.kind_string()}.\" ) update def update ( changes : dict [ str , typing . Any ] ) -> Self Update the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update(cls, changes: dict[str, Any]) -> Self: \"Update the settings with data specified in changes; not meant for config\" return cls.get()._update(changes)._set() # pylint: disable=protected-access SettingsSectionBase class SettingsSectionBase ( ) Base class for all SettingsSection classes (so that we can bound a TypeVar) ??? example \"View Source\" @dataclass(frozen=True) class SettingsSectionBase(ContainerSectionBase): \"\"\"Base class for all SettingsSection classes (so that we can bound a TypeVar)\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Settings'\" return \"Settings\" Ancestors (in MRO) application_settings.container_section_base.ContainerSectionBase abc.ABC Static methods get def get ( ) -> Self Get the singleton; if not existing, create it. Reading file only done for a container. ??? example \"View Source\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none kind_string def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Settings' ??? example \"View Source\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Settings'\" return \"Settings\" set def set ( data : dict [ str , typing . Any ] ) -> Self Create a new dataclass instance using data and set the singleton. ??? example \"View Source\" @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set() update def update ( changes : dict [ str , typing . Any ] ) -> Self Update the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update(cls, changes: dict[str, Any]) -> Self: \"Update the settings with data specified in changes; not meant for config\" return cls.get()._update(changes)._set() # pylint: disable=protected-access","title":"Index"},{"location":"reference/application_settings/#module-application_settings","text":"Module for loading and retrieving parameters for configuration and settings. ??? example \"View Source\" \"\"\"Module for loading and retrieving parameters for configuration and settings.\"\"\" from importlib.metadata import version from application_settings.configuring_base import ConfigBase, ConfigSectionBase, ConfigT from application_settings.container_section_base import SectionTypeStr from application_settings.convenience import ( config_filepath_from_cli, parameters_folderpath_from_cli, settings_filepath_from_cli, ) from application_settings.settings_base import ( SettingsBase, SettingsSectionBase, SettingsT, ) from application_settings.type_notation_helper import PathOpt, PathOrStr __version__ = version(\"application_settings\") __all__ = [ \"ConfigSectionBase\", \"ConfigBase\", \"ConfigT\", \"PathOpt\", \"PathOrStr\", \"SectionTypeStr\", \"SettingsSectionBase\", \"SettingsBase\", \"SettingsT\", \"config_filepath_from_cli\", \"settings_filepath_from_cli\", \"parameters_folderpath_from_cli\", ]","title":"Module application_settings"},{"location":"reference/application_settings/#sub-modules","text":"application_settings.configuring_base application_settings.container_base application_settings.container_section_base application_settings.convenience application_settings.settings_base application_settings.type_notation_helper","title":"Sub-modules"},{"location":"reference/application_settings/#variables","text":"ConfigT PathOpt PathOrStr SectionTypeStr SettingsT","title":"Variables"},{"location":"reference/application_settings/#functions","text":"","title":"Functions"},{"location":"reference/application_settings/#config_filepath_from_cli","text":"def config_filepath_from_cli ( config_class : type [ ~ ConfigT ], parser : argparse . ArgumentParser = ArgumentParser ( prog = 'portray' , usage = None , description = None , formatter_class =< class ' argparse . HelpFormatter '>, conflict_handler=' error ', add_help=True), short_option : str = '-c' , long_option : str = '--config_filepath' , load : bool = False ) -> argparse . ArgumentParser Add a commandline option for the config file and set filepath if it is given ??? example \"View Source\" def config_filepath_from_cli( config_class: type[ConfigT], parser: ArgumentParser = ArgumentParser(), short_option: str = \"-c\", long_option: str = \"--config_filepath\", load: bool = False, ) -> ArgumentParser: \"\"\"Add a commandline option for the config file and set filepath if it is given\"\"\" helptext: str = \"Path of the configuration file\" return _parameters_filepath_from_cli( config_class=config_class, settings_class=None, parser=parser, short_option=short_option, long_option=long_option, helptext=helptext, load=load, )","title":"config_filepath_from_cli"},{"location":"reference/application_settings/#parameters_folderpath_from_cli","text":"def parameters_folderpath_from_cli ( config_class : type [ ~ ConfigT ], settings_class : type [ ~ SettingsT ], parser : argparse . ArgumentParser = ArgumentParser ( prog = 'portray' , usage = None , description = None , formatter_class =< class ' argparse . HelpFormatter '>, conflict_handler=' error ', add_help=True), short_option : str = '-p' , long_option : str = '--parameters_folderpath' , load : bool = False ) -> argparse . ArgumentParser Add a commandline option '--parameters_folderpath' for the common config and settings folder and set filepaths if it is given. Default filenames will be appended to the folderpath for config and settings. ??? example \"View Source\" def parameters_folderpath_from_cli( # pylint: disable=too-many-arguments config_class: type[ConfigT], settings_class: type[SettingsT], parser: ArgumentParser = ArgumentParser(), short_option: str = \"-p\", long_option: str = \"--parameters_folderpath\", load: bool = False, ) -> ArgumentParser: \"\"\"Add a commandline option '--parameters_folderpath' for the common config and settings folder and set filepaths if it is given. Default filenames will be appended to the folderpath for config and settings.\"\"\" helptext: str = \"Common path of the config file and settings file\" return _parameters_filepath_from_cli( config_class=config_class, settings_class=settings_class, parser=parser, short_option=short_option, long_option=long_option, helptext=helptext, load=load, )","title":"parameters_folderpath_from_cli"},{"location":"reference/application_settings/#settings_filepath_from_cli","text":"def settings_filepath_from_cli ( settings_class : type [ ~ SettingsT ], parser : argparse . ArgumentParser = ArgumentParser ( prog = 'portray' , usage = None , description = None , formatter_class =< class ' argparse . HelpFormatter '>, conflict_handler=' error ', add_help=True), short_option : str = '-s' , long_option : str = '--settings_filepath' , load : bool = False ) -> argparse . ArgumentParser Add a commandline option for the settings file and set filepath if it is given ??? example \"View Source\" def settings_filepath_from_cli( settings_class: type[SettingsT], parser: ArgumentParser = ArgumentParser(), short_option: str = \"-s\", long_option: str = \"--settings_filepath\", load: bool = False, ) -> ArgumentParser: \"\"\"Add a commandline option for the settings file and set filepath if it is given\"\"\" helptext: str = \"Path of the settings file\" return _parameters_filepath_from_cli( config_class=None, settings_class=settings_class, parser=parser, short_option=short_option, long_option=long_option, helptext=helptext, load=load, )","title":"settings_filepath_from_cli"},{"location":"reference/application_settings/#classes","text":"","title":"Classes"},{"location":"reference/application_settings/#configbase","text":"class ConfigBase ( ) Base class for main Config class ??? example \"View Source\" @dataclass(frozen=True) class ConfigBase(ContainerBase): \"\"\"Base class for main Config class\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Config'\" return \"Config\" @classmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" return FileFormat.TOML @classmethod def update( cls: type[\"ConfigBase\"], changes: dict[str, dict[str, Any]] ) -> \"ConfigBase\": \"Update and save the settings with data specified in changes; not meant for config\" raise TypeError( \"Configs should not be updated runtime; consider converting to settings.\" )","title":"ConfigBase"},{"location":"reference/application_settings/#ancestors-in-mro","text":"application_settings.container_base.ContainerBase application_settings.container_section_base.ContainerSectionBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/application_settings/#static-methods","text":"","title":"Static methods"},{"location":"reference/application_settings/#default_file_format","text":"def default_file_format ( ) -> application_settings . container_base . FileFormat Return the default file format ??? example \"View Source\" @classmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" return FileFormat.TOML","title":"default_file_format"},{"location":"reference/application_settings/#default_filename","text":"def default_filename ( ) -> str Return the kind_string, lowercase, with the extension that fits the file_format. ??? example \"View Source\" @classmethod def default_filename(cls) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\"","title":"default_filename"},{"location":"reference/application_settings/#default_filepath","text":"def default_filepath ( ) -> pathlib . Path | None Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. ??? example \"View Source\" @classmethod def default_filepath(cls) -> PathOpt: \"\"\" Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. \"\"\" return Path.home() / cls.default_foldername() / cls.default_filename()","title":"default_filepath"},{"location":"reference/application_settings/#default_foldername","text":"def default_foldername ( ) -> str Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words. ??? example \"View Source\" @classmethod def default_foldername(cls) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" if (kind_str := cls.kind_string()) == cls.__name__: return f\".{kind_str.lower()}\" return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() )","title":"default_foldername"},{"location":"reference/application_settings/#filepath","text":"def filepath ( ) -> pathlib . Path | None Return the path for the file that holds the config / settings. ??? example \"View Source\" @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath())","title":"filepath"},{"location":"reference/application_settings/#get","text":"def get ( ) -> Self Get the singleton; if not existing, create it. Reading file only done for a container. ??? example \"View Source\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none","title":"get"},{"location":"reference/application_settings/#kind_string","text":"def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Config' ??? example \"View Source\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Config'\" return \"Config\"","title":"kind_string"},{"location":"reference/application_settings/#load","text":"def load ( throw_if_file_not_found : bool = False ) -> Self Create a new singleton ??? example \"View Source\" @classmethod def load(cls, throw_if_file_not_found: bool = False) -> Self: \"\"\"Create a new singleton\"\"\" return cls._create_instance(throw_if_file_not_found)","title":"load"},{"location":"reference/application_settings/#set","text":"def set ( data : dict [ str , typing . Any ] ) -> Self Create a new dataclass instance using data and set the singleton. ??? example \"View Source\" @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set()","title":"set"},{"location":"reference/application_settings/#set_filepath","text":"def set_filepath ( file_path : pathlib . Path | str = '' , load : bool = False ) -> None Set the path for the file (a singleton). ??? example \"View Source\" @classmethod def set_filepath(cls, file_path: PathOrStr = \"\", load: bool = False) -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) if load: cls.load() else: if cls._get() is not None: print( f\"Warning: filepath has been set the but file is not loaded into the {cls.kind_string()}.\" )","title":"set_filepath"},{"location":"reference/application_settings/#update","text":"def update ( changes : dict [ str , dict [ str , typing . Any ]] ) -> 'ConfigBase' Update and save the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update( cls: type[\"ConfigBase\"], changes: dict[str, dict[str, Any]] ) -> \"ConfigBase\": \"Update and save the settings with data specified in changes; not meant for config\" raise TypeError( \"Configs should not be updated runtime; consider converting to settings.\" )","title":"update"},{"location":"reference/application_settings/#configsectionbase","text":"class ConfigSectionBase ( ) Base class for all ConfigSection classes (so that we can bound a TypeVar) ??? example \"View Source\" @dataclass(frozen=True) class ConfigSectionBase(ContainerSectionBase): \"\"\"Base class for all ConfigSection classes (so that we can bound a TypeVar)\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Config'\" return \"Config\"","title":"ConfigSectionBase"},{"location":"reference/application_settings/#ancestors-in-mro_1","text":"application_settings.container_section_base.ContainerSectionBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/application_settings/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/application_settings/#get_1","text":"def get ( ) -> Self Get the singleton; if not existing, create it. Reading file only done for a container. ??? example \"View Source\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none","title":"get"},{"location":"reference/application_settings/#kind_string_1","text":"def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Config' ??? example \"View Source\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Config'\" return \"Config\"","title":"kind_string"},{"location":"reference/application_settings/#set_1","text":"def set ( data : dict [ str , typing . Any ] ) -> Self Create a new dataclass instance using data and set the singleton. ??? example \"View Source\" @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set()","title":"set"},{"location":"reference/application_settings/#update_1","text":"def update ( changes : dict [ str , typing . Any ] ) -> Self Update the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update(cls, changes: dict[str, Any]) -> Self: \"Update the settings with data specified in changes; not meant for config\" return cls.get()._update(changes)._set() # pylint: disable=protected-access","title":"update"},{"location":"reference/application_settings/#settingsbase","text":"class SettingsBase ( ) Base class for main Settings class ??? example \"View Source\" @dataclass(frozen=True) class SettingsBase(ContainerBase): \"\"\"Base class for main Settings class\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Settings'\" return \"Settings\" @classmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" return FileFormat.JSON","title":"SettingsBase"},{"location":"reference/application_settings/#ancestors-in-mro_2","text":"application_settings.container_base.ContainerBase application_settings.container_section_base.ContainerSectionBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/application_settings/#static-methods_2","text":"","title":"Static methods"},{"location":"reference/application_settings/#default_file_format_1","text":"def default_file_format ( ) -> application_settings . container_base . FileFormat Return the default file format ??? example \"View Source\" @classmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" return FileFormat.JSON","title":"default_file_format"},{"location":"reference/application_settings/#default_filename_1","text":"def default_filename ( ) -> str Return the kind_string, lowercase, with the extension that fits the file_format. ??? example \"View Source\" @classmethod def default_filename(cls) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\"","title":"default_filename"},{"location":"reference/application_settings/#default_filepath_1","text":"def default_filepath ( ) -> pathlib . Path | None Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. ??? example \"View Source\" @classmethod def default_filepath(cls) -> PathOpt: \"\"\" Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. \"\"\" return Path.home() / cls.default_foldername() / cls.default_filename()","title":"default_filepath"},{"location":"reference/application_settings/#default_foldername_1","text":"def default_foldername ( ) -> str Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words. ??? example \"View Source\" @classmethod def default_foldername(cls) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" if (kind_str := cls.kind_string()) == cls.__name__: return f\".{kind_str.lower()}\" return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() )","title":"default_foldername"},{"location":"reference/application_settings/#filepath_1","text":"def filepath ( ) -> pathlib . Path | None Return the path for the file that holds the config / settings. ??? example \"View Source\" @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath())","title":"filepath"},{"location":"reference/application_settings/#get_2","text":"def get ( ) -> Self Get the singleton; if not existing, create it. Reading file only done for a container. ??? example \"View Source\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none","title":"get"},{"location":"reference/application_settings/#kind_string_2","text":"def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Settings' ??? example \"View Source\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Settings'\" return \"Settings\"","title":"kind_string"},{"location":"reference/application_settings/#load_1","text":"def load ( throw_if_file_not_found : bool = False ) -> Self Create a new singleton ??? example \"View Source\" @classmethod def load(cls, throw_if_file_not_found: bool = False) -> Self: \"\"\"Create a new singleton\"\"\" return cls._create_instance(throw_if_file_not_found)","title":"load"},{"location":"reference/application_settings/#set_2","text":"def set ( data : dict [ str , typing . Any ] ) -> Self Create a new dataclass instance using data and set the singleton. ??? example \"View Source\" @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set()","title":"set"},{"location":"reference/application_settings/#set_filepath_1","text":"def set_filepath ( file_path : pathlib . Path | str = '' , load : bool = False ) -> None Set the path for the file (a singleton). ??? example \"View Source\" @classmethod def set_filepath(cls, file_path: PathOrStr = \"\", load: bool = False) -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) if load: cls.load() else: if cls._get() is not None: print( f\"Warning: filepath has been set the but file is not loaded into the {cls.kind_string()}.\" )","title":"set_filepath"},{"location":"reference/application_settings/#update_2","text":"def update ( changes : dict [ str , typing . Any ] ) -> Self Update the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update(cls, changes: dict[str, Any]) -> Self: \"Update the settings with data specified in changes; not meant for config\" return cls.get()._update(changes)._set() # pylint: disable=protected-access","title":"update"},{"location":"reference/application_settings/#settingssectionbase","text":"class SettingsSectionBase ( ) Base class for all SettingsSection classes (so that we can bound a TypeVar) ??? example \"View Source\" @dataclass(frozen=True) class SettingsSectionBase(ContainerSectionBase): \"\"\"Base class for all SettingsSection classes (so that we can bound a TypeVar)\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Settings'\" return \"Settings\"","title":"SettingsSectionBase"},{"location":"reference/application_settings/#ancestors-in-mro_3","text":"application_settings.container_section_base.ContainerSectionBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/application_settings/#static-methods_3","text":"","title":"Static methods"},{"location":"reference/application_settings/#get_3","text":"def get ( ) -> Self Get the singleton; if not existing, create it. Reading file only done for a container. ??? example \"View Source\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none","title":"get"},{"location":"reference/application_settings/#kind_string_3","text":"def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Settings' ??? example \"View Source\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Settings'\" return \"Settings\"","title":"kind_string"},{"location":"reference/application_settings/#set_3","text":"def set ( data : dict [ str , typing . Any ] ) -> Self Create a new dataclass instance using data and set the singleton. ??? example \"View Source\" @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set()","title":"set"},{"location":"reference/application_settings/#update_3","text":"def update ( changes : dict [ str , typing . Any ] ) -> Self Update the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update(cls, changes: dict[str, Any]) -> Self: \"Update the settings with data specified in changes; not meant for config\" return cls.get()._update(changes)._set() # pylint: disable=protected-access","title":"update"},{"location":"reference/application_settings/configuring_base/","text":"Module application_settings.configuring_base Module for handling configuration. ??? example \"View Source\" \"\"\"Module for handling configuration.\"\"\" from typing import Any, TypeVar from pydantic.dataclasses import dataclass from application_settings.container_base import ContainerBase, FileFormat from application_settings.container_section_base import ( ContainerSectionBase, SectionTypeStr, ) ConfigT = TypeVar(\"ConfigT\", bound=\"ConfigBase\") ConfigT.__doc__ = \"Represents ConfigBase and all subclasses\" @dataclass(frozen=True) class ConfigSectionBase(ContainerSectionBase): \"\"\"Base class for all ConfigSection classes (so that we can bound a TypeVar)\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Config'\" return \"Config\" @dataclass(frozen=True) class ConfigBase(ContainerBase): \"\"\"Base class for main Config class\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Config'\" return \"Config\" @classmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" return FileFormat.TOML @classmethod def update( cls: type[\"ConfigBase\"], changes: dict[str, dict[str, Any]] ) -> \"ConfigBase\": \"Update and save the settings with data specified in changes; not meant for config\" raise TypeError( \"Configs should not be updated runtime; consider converting to settings.\" ) Variables ConfigT Classes ConfigBase class ConfigBase ( ) Base class for main Config class ??? example \"View Source\" @dataclass(frozen=True) class ConfigBase(ContainerBase): \"\"\"Base class for main Config class\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Config'\" return \"Config\" @classmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" return FileFormat.TOML @classmethod def update( cls: type[\"ConfigBase\"], changes: dict[str, dict[str, Any]] ) -> \"ConfigBase\": \"Update and save the settings with data specified in changes; not meant for config\" raise TypeError( \"Configs should not be updated runtime; consider converting to settings.\" ) Ancestors (in MRO) application_settings.container_base.ContainerBase application_settings.container_section_base.ContainerSectionBase abc.ABC Static methods default_file_format def default_file_format ( ) -> application_settings . container_base . FileFormat Return the default file format ??? example \"View Source\" @classmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" return FileFormat.TOML default_filename def default_filename ( ) -> str Return the kind_string, lowercase, with the extension that fits the file_format. ??? example \"View Source\" @classmethod def default_filename(cls) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\" default_filepath def default_filepath ( ) -> pathlib . Path | None Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. ??? example \"View Source\" @classmethod def default_filepath(cls) -> PathOpt: \"\"\" Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. \"\"\" return Path.home() / cls.default_foldername() / cls.default_filename() default_foldername def default_foldername ( ) -> str Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words. ??? example \"View Source\" @classmethod def default_foldername(cls) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" if (kind_str := cls.kind_string()) == cls.__name__: return f\".{kind_str.lower()}\" return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() ) filepath def filepath ( ) -> pathlib . Path | None Return the path for the file that holds the config / settings. ??? example \"View Source\" @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath()) get def get ( ) -> Self Get the singleton; if not existing, create it. Reading file only done for a container. ??? example \"View Source\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none kind_string def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Config' ??? example \"View Source\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Config'\" return \"Config\" load def load ( throw_if_file_not_found : bool = False ) -> Self Create a new singleton ??? example \"View Source\" @classmethod def load(cls, throw_if_file_not_found: bool = False) -> Self: \"\"\"Create a new singleton\"\"\" return cls._create_instance(throw_if_file_not_found) set def set ( data : dict [ str , typing . Any ] ) -> Self Create a new dataclass instance using data and set the singleton. ??? example \"View Source\" @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set() set_filepath def set_filepath ( file_path : pathlib . Path | str = '' , load : bool = False ) -> None Set the path for the file (a singleton). ??? example \"View Source\" @classmethod def set_filepath(cls, file_path: PathOrStr = \"\", load: bool = False) -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) if load: cls.load() else: if cls._get() is not None: print( f\"Warning: filepath has been set the but file is not loaded into the {cls.kind_string()}.\" ) update def update ( changes : dict [ str , dict [ str , typing . Any ]] ) -> 'ConfigBase' Update and save the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update( cls: type[\"ConfigBase\"], changes: dict[str, dict[str, Any]] ) -> \"ConfigBase\": \"Update and save the settings with data specified in changes; not meant for config\" raise TypeError( \"Configs should not be updated runtime; consider converting to settings.\" ) ConfigSectionBase class ConfigSectionBase ( ) Base class for all ConfigSection classes (so that we can bound a TypeVar) ??? example \"View Source\" @dataclass(frozen=True) class ConfigSectionBase(ContainerSectionBase): \"\"\"Base class for all ConfigSection classes (so that we can bound a TypeVar)\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Config'\" return \"Config\" Ancestors (in MRO) application_settings.container_section_base.ContainerSectionBase abc.ABC Static methods get def get ( ) -> Self Get the singleton; if not existing, create it. Reading file only done for a container. ??? example \"View Source\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none kind_string def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Config' ??? example \"View Source\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Config'\" return \"Config\" set def set ( data : dict [ str , typing . Any ] ) -> Self Create a new dataclass instance using data and set the singleton. ??? example \"View Source\" @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set() update def update ( changes : dict [ str , typing . Any ] ) -> Self Update the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update(cls, changes: dict[str, Any]) -> Self: \"Update the settings with data specified in changes; not meant for config\" return cls.get()._update(changes)._set() # pylint: disable=protected-access","title":"Configuring Base"},{"location":"reference/application_settings/configuring_base/#module-application_settingsconfiguring_base","text":"Module for handling configuration. ??? example \"View Source\" \"\"\"Module for handling configuration.\"\"\" from typing import Any, TypeVar from pydantic.dataclasses import dataclass from application_settings.container_base import ContainerBase, FileFormat from application_settings.container_section_base import ( ContainerSectionBase, SectionTypeStr, ) ConfigT = TypeVar(\"ConfigT\", bound=\"ConfigBase\") ConfigT.__doc__ = \"Represents ConfigBase and all subclasses\" @dataclass(frozen=True) class ConfigSectionBase(ContainerSectionBase): \"\"\"Base class for all ConfigSection classes (so that we can bound a TypeVar)\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Config'\" return \"Config\" @dataclass(frozen=True) class ConfigBase(ContainerBase): \"\"\"Base class for main Config class\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Config'\" return \"Config\" @classmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" return FileFormat.TOML @classmethod def update( cls: type[\"ConfigBase\"], changes: dict[str, dict[str, Any]] ) -> \"ConfigBase\": \"Update and save the settings with data specified in changes; not meant for config\" raise TypeError( \"Configs should not be updated runtime; consider converting to settings.\" )","title":"Module application_settings.configuring_base"},{"location":"reference/application_settings/configuring_base/#variables","text":"ConfigT","title":"Variables"},{"location":"reference/application_settings/configuring_base/#classes","text":"","title":"Classes"},{"location":"reference/application_settings/configuring_base/#configbase","text":"class ConfigBase ( ) Base class for main Config class ??? example \"View Source\" @dataclass(frozen=True) class ConfigBase(ContainerBase): \"\"\"Base class for main Config class\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Config'\" return \"Config\" @classmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" return FileFormat.TOML @classmethod def update( cls: type[\"ConfigBase\"], changes: dict[str, dict[str, Any]] ) -> \"ConfigBase\": \"Update and save the settings with data specified in changes; not meant for config\" raise TypeError( \"Configs should not be updated runtime; consider converting to settings.\" )","title":"ConfigBase"},{"location":"reference/application_settings/configuring_base/#ancestors-in-mro","text":"application_settings.container_base.ContainerBase application_settings.container_section_base.ContainerSectionBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/application_settings/configuring_base/#static-methods","text":"","title":"Static methods"},{"location":"reference/application_settings/configuring_base/#default_file_format","text":"def default_file_format ( ) -> application_settings . container_base . FileFormat Return the default file format ??? example \"View Source\" @classmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" return FileFormat.TOML","title":"default_file_format"},{"location":"reference/application_settings/configuring_base/#default_filename","text":"def default_filename ( ) -> str Return the kind_string, lowercase, with the extension that fits the file_format. ??? example \"View Source\" @classmethod def default_filename(cls) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\"","title":"default_filename"},{"location":"reference/application_settings/configuring_base/#default_filepath","text":"def default_filepath ( ) -> pathlib . Path | None Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. ??? example \"View Source\" @classmethod def default_filepath(cls) -> PathOpt: \"\"\" Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. \"\"\" return Path.home() / cls.default_foldername() / cls.default_filename()","title":"default_filepath"},{"location":"reference/application_settings/configuring_base/#default_foldername","text":"def default_foldername ( ) -> str Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words. ??? example \"View Source\" @classmethod def default_foldername(cls) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" if (kind_str := cls.kind_string()) == cls.__name__: return f\".{kind_str.lower()}\" return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() )","title":"default_foldername"},{"location":"reference/application_settings/configuring_base/#filepath","text":"def filepath ( ) -> pathlib . Path | None Return the path for the file that holds the config / settings. ??? example \"View Source\" @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath())","title":"filepath"},{"location":"reference/application_settings/configuring_base/#get","text":"def get ( ) -> Self Get the singleton; if not existing, create it. Reading file only done for a container. ??? example \"View Source\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none","title":"get"},{"location":"reference/application_settings/configuring_base/#kind_string","text":"def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Config' ??? example \"View Source\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Config'\" return \"Config\"","title":"kind_string"},{"location":"reference/application_settings/configuring_base/#load","text":"def load ( throw_if_file_not_found : bool = False ) -> Self Create a new singleton ??? example \"View Source\" @classmethod def load(cls, throw_if_file_not_found: bool = False) -> Self: \"\"\"Create a new singleton\"\"\" return cls._create_instance(throw_if_file_not_found)","title":"load"},{"location":"reference/application_settings/configuring_base/#set","text":"def set ( data : dict [ str , typing . Any ] ) -> Self Create a new dataclass instance using data and set the singleton. ??? example \"View Source\" @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set()","title":"set"},{"location":"reference/application_settings/configuring_base/#set_filepath","text":"def set_filepath ( file_path : pathlib . Path | str = '' , load : bool = False ) -> None Set the path for the file (a singleton). ??? example \"View Source\" @classmethod def set_filepath(cls, file_path: PathOrStr = \"\", load: bool = False) -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) if load: cls.load() else: if cls._get() is not None: print( f\"Warning: filepath has been set the but file is not loaded into the {cls.kind_string()}.\" )","title":"set_filepath"},{"location":"reference/application_settings/configuring_base/#update","text":"def update ( changes : dict [ str , dict [ str , typing . Any ]] ) -> 'ConfigBase' Update and save the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update( cls: type[\"ConfigBase\"], changes: dict[str, dict[str, Any]] ) -> \"ConfigBase\": \"Update and save the settings with data specified in changes; not meant for config\" raise TypeError( \"Configs should not be updated runtime; consider converting to settings.\" )","title":"update"},{"location":"reference/application_settings/configuring_base/#configsectionbase","text":"class ConfigSectionBase ( ) Base class for all ConfigSection classes (so that we can bound a TypeVar) ??? example \"View Source\" @dataclass(frozen=True) class ConfigSectionBase(ContainerSectionBase): \"\"\"Base class for all ConfigSection classes (so that we can bound a TypeVar)\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Config'\" return \"Config\"","title":"ConfigSectionBase"},{"location":"reference/application_settings/configuring_base/#ancestors-in-mro_1","text":"application_settings.container_section_base.ContainerSectionBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/application_settings/configuring_base/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/application_settings/configuring_base/#get_1","text":"def get ( ) -> Self Get the singleton; if not existing, create it. Reading file only done for a container. ??? example \"View Source\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none","title":"get"},{"location":"reference/application_settings/configuring_base/#kind_string_1","text":"def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Config' ??? example \"View Source\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Config'\" return \"Config\"","title":"kind_string"},{"location":"reference/application_settings/configuring_base/#set_1","text":"def set ( data : dict [ str , typing . Any ] ) -> Self Create a new dataclass instance using data and set the singleton. ??? example \"View Source\" @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set()","title":"set"},{"location":"reference/application_settings/configuring_base/#update_1","text":"def update ( changes : dict [ str , typing . Any ] ) -> Self Update the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update(cls, changes: dict[str, Any]) -> Self: \"Update the settings with data specified in changes; not meant for config\" return cls.get()._update(changes)._set() # pylint: disable=protected-access","title":"update"},{"location":"reference/application_settings/container_base/","text":"Module application_settings.container_base Base class for a container (= root section) for configuration and settings. ??? example \"View Source\" \"\"\"Base class for a container (= root section) for configuration and settings.\"\"\" import json import sys from abc import ABC, abstractmethod from dataclasses import asdict from enum import Enum, unique from pathlib import Path from re import sub from typing import Any import tomli_w from pathvalidate import is_valid_filepath from pydantic.dataclasses import dataclass from application_settings.container_section_base import ContainerSectionBase from application_settings.type_notation_helper import PathOpt, PathOrStr if sys.version_info >= (3, 11): import tomllib from typing import Self else: import tomli as tomllib from typing_extensions import Self @unique class FileFormat(Enum): \"File formats that are supported by application_settings\" TOML = \"toml\" JSON = \"json\" @dataclass(frozen=True) class ContainerBase(ContainerSectionBase, ABC): \"\"\"Base class for Config and Settings container classes\"\"\" @classmethod @abstractmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" @classmethod def default_foldername(cls) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" if (kind_str := cls.kind_string()) == cls.__name__: return f\".{kind_str.lower()}\" return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() ) @classmethod def default_filename(cls) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\" @classmethod def default_filepath(cls) -> PathOpt: \"\"\" Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. \"\"\" return Path.home() / cls.default_foldername() / cls.default_filename() @classmethod def set_filepath(cls, file_path: PathOrStr = \"\", load: bool = False) -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) if load: cls.load() else: if cls._get() is not None: print( f\"Warning: filepath has been set the but file is not loaded into the {cls.kind_string()}.\" ) @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath()) @classmethod def load(cls, throw_if_file_not_found: bool = False) -> Self: \"\"\"Create a new singleton\"\"\" return cls._create_instance(throw_if_file_not_found) @classmethod def _create_instance(cls, throw_if_file_not_found: bool = False) -> Self: \"\"\"Load stored data, instantiate the Container with it, store it in the singleton and return it.\"\"\" # get whatever is stored in the config/settings file data_stored = cls._get_saved_data(throw_if_file_not_found) # instantiate and store the Container with the stored data return cls.set(data_stored) def _update(self, changes: dict[str, Any]) -> Self: \"Update and save the settings with data specified in changes; not meant for config\" return ( super() # pylint: disable=protected-access,no-member ._update(changes) ._save() ) def _save(self) -> Self: \"\"\"Private method to save the singleton to file.\"\"\" if path := self.filepath(): path.parent.mkdir(parents=True, exist_ok=True) if (ext := path.suffix[1:].lower()) == FileFormat.TOML.value: with path.open(mode=\"wb\") as fptr: tomli_w.dump(asdict(self), fptr) elif ext == FileFormat.JSON.value: with path.open(mode=\"w\") as fptr: json.dump(asdict(self), fptr) else: print(f\"Unknown file format {ext} given in {path}.\") else: # This situation can occur if no valid path was given as an argument, and # the default path is set to None. raise RuntimeError( f\"No path specified for {self.kind_string().lower()} file, cannot be saved.\" ) return self @classmethod def _get_saved_data(cls, throw_if_file_not_found: bool = False) -> dict[str, Any]: \"\"\"Get the data stored in the parameter file\"\"\" data_stored: dict[str, Any] = {} path = cls.filepath() if path is None or not path.is_file(): err_mess = ( f\"Path {str(path)} not valid for {cls.kind_string().lower()} file.\" ) if throw_if_file_not_found: raise FileNotFoundError(err_mess) print(err_mess, \"Trying with defaults, but this may not work.\") return {} if (ext := path.suffix[1:].lower()) == str(FileFormat.TOML.value): with path.open(mode=\"rb\") as fptr: data_stored = tomllib.load(fptr) elif ext == str(FileFormat.JSON.value): with path.open(mode=\"r\") as fptr: data_stored = json.load(fptr) else: print(f\"Unknown file format {ext} given in {path}.\") return data_stored _ALL_PATHS: dict[int, PathOpt] = {} Classes ContainerBase class ContainerBase ( ) Base class for Config and Settings container classes ??? example \"View Source\" @dataclass(frozen=True) class ContainerBase(ContainerSectionBase, ABC): \"\"\"Base class for Config and Settings container classes\"\"\" @classmethod @abstractmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" @classmethod def default_foldername(cls) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" if (kind_str := cls.kind_string()) == cls.__name__: return f\".{kind_str.lower()}\" return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() ) @classmethod def default_filename(cls) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\" @classmethod def default_filepath(cls) -> PathOpt: \"\"\" Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. \"\"\" return Path.home() / cls.default_foldername() / cls.default_filename() @classmethod def set_filepath(cls, file_path: PathOrStr = \"\", load: bool = False) -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) if load: cls.load() else: if cls._get() is not None: print( f\"Warning: filepath has been set the but file is not loaded into the {cls.kind_string()}.\" ) @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath()) @classmethod def load(cls, throw_if_file_not_found: bool = False) -> Self: \"\"\"Create a new singleton\"\"\" return cls._create_instance(throw_if_file_not_found) @classmethod def _create_instance(cls, throw_if_file_not_found: bool = False) -> Self: \"\"\"Load stored data, instantiate the Container with it, store it in the singleton and return it.\"\"\" # get whatever is stored in the config/settings file data_stored = cls._get_saved_data(throw_if_file_not_found) # instantiate and store the Container with the stored data return cls.set(data_stored) def _update(self, changes: dict[str, Any]) -> Self: \"Update and save the settings with data specified in changes; not meant for config\" return ( super() # pylint: disable=protected-access,no-member ._update(changes) ._save() ) def _save(self) -> Self: \"\"\"Private method to save the singleton to file.\"\"\" if path := self.filepath(): path.parent.mkdir(parents=True, exist_ok=True) if (ext := path.suffix[1:].lower()) == FileFormat.TOML.value: with path.open(mode=\"wb\") as fptr: tomli_w.dump(asdict(self), fptr) elif ext == FileFormat.JSON.value: with path.open(mode=\"w\") as fptr: json.dump(asdict(self), fptr) else: print(f\"Unknown file format {ext} given in {path}.\") else: # This situation can occur if no valid path was given as an argument, and # the default path is set to None. raise RuntimeError( f\"No path specified for {self.kind_string().lower()} file, cannot be saved.\" ) return self @classmethod def _get_saved_data(cls, throw_if_file_not_found: bool = False) -> dict[str, Any]: \"\"\"Get the data stored in the parameter file\"\"\" data_stored: dict[str, Any] = {} path = cls.filepath() if path is None or not path.is_file(): err_mess = ( f\"Path {str(path)} not valid for {cls.kind_string().lower()} file.\" ) if throw_if_file_not_found: raise FileNotFoundError(err_mess) print(err_mess, \"Trying with defaults, but this may not work.\") return {} if (ext := path.suffix[1:].lower()) == str(FileFormat.TOML.value): with path.open(mode=\"rb\") as fptr: data_stored = tomllib.load(fptr) elif ext == str(FileFormat.JSON.value): with path.open(mode=\"r\") as fptr: data_stored = json.load(fptr) else: print(f\"Unknown file format {ext} given in {path}.\") return data_stored Ancestors (in MRO) application_settings.container_section_base.ContainerSectionBase abc.ABC Descendants application_settings.configuring_base.ConfigBase application_settings.settings_base.SettingsBase Static methods default_file_format def default_file_format ( ) -> application_settings . container_base . FileFormat Return the default file format ??? example \"View Source\" @classmethod @abstractmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" default_filename def default_filename ( ) -> str Return the kind_string, lowercase, with the extension that fits the file_format. ??? example \"View Source\" @classmethod def default_filename(cls) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\" default_filepath def default_filepath ( ) -> pathlib . Path | None Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. ??? example \"View Source\" @classmethod def default_filepath(cls) -> PathOpt: \"\"\" Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. \"\"\" return Path.home() / cls.default_foldername() / cls.default_filename() default_foldername def default_foldername ( ) -> str Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words. ??? example \"View Source\" @classmethod def default_foldername(cls) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" if (kind_str := cls.kind_string()) == cls.__name__: return f\".{kind_str.lower()}\" return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() ) filepath def filepath ( ) -> pathlib . Path | None Return the path for the file that holds the config / settings. ??? example \"View Source\" @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath()) get def get ( ) -> Self Get the singleton; if not existing, create it. Reading file only done for a container. ??? example \"View Source\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none kind_string def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return either 'Config' or 'Settings' ??? example \"View Source\" @classmethod @abstractmethod def kind_string(cls) -> SectionTypeStr: \"Return either 'Config' or 'Settings'\" load def load ( throw_if_file_not_found : bool = False ) -> Self Create a new singleton ??? example \"View Source\" @classmethod def load(cls, throw_if_file_not_found: bool = False) -> Self: \"\"\"Create a new singleton\"\"\" return cls._create_instance(throw_if_file_not_found) set def set ( data : dict [ str , typing . Any ] ) -> Self Create a new dataclass instance using data and set the singleton. ??? example \"View Source\" @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set() set_filepath def set_filepath ( file_path : pathlib . Path | str = '' , load : bool = False ) -> None Set the path for the file (a singleton). ??? example \"View Source\" @classmethod def set_filepath(cls, file_path: PathOrStr = \"\", load: bool = False) -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) if load: cls.load() else: if cls._get() is not None: print( f\"Warning: filepath has been set the but file is not loaded into the {cls.kind_string()}.\" ) update def update ( changes : dict [ str , typing . Any ] ) -> Self Update the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update(cls, changes: dict[str, Any]) -> Self: \"Update the settings with data specified in changes; not meant for config\" return cls.get()._update(changes)._set() # pylint: disable=protected-access FileFormat class FileFormat ( * args , ** kwds ) File formats that are supported by application_settings ??? example \"View Source\" @unique class FileFormat(Enum): \"File formats that are supported by application_settings\" TOML = \"toml\" JSON = \"json\" Ancestors (in MRO) enum.Enum Class variables JSON TOML name value","title":"Container Base"},{"location":"reference/application_settings/container_base/#module-application_settingscontainer_base","text":"Base class for a container (= root section) for configuration and settings. ??? example \"View Source\" \"\"\"Base class for a container (= root section) for configuration and settings.\"\"\" import json import sys from abc import ABC, abstractmethod from dataclasses import asdict from enum import Enum, unique from pathlib import Path from re import sub from typing import Any import tomli_w from pathvalidate import is_valid_filepath from pydantic.dataclasses import dataclass from application_settings.container_section_base import ContainerSectionBase from application_settings.type_notation_helper import PathOpt, PathOrStr if sys.version_info >= (3, 11): import tomllib from typing import Self else: import tomli as tomllib from typing_extensions import Self @unique class FileFormat(Enum): \"File formats that are supported by application_settings\" TOML = \"toml\" JSON = \"json\" @dataclass(frozen=True) class ContainerBase(ContainerSectionBase, ABC): \"\"\"Base class for Config and Settings container classes\"\"\" @classmethod @abstractmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" @classmethod def default_foldername(cls) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" if (kind_str := cls.kind_string()) == cls.__name__: return f\".{kind_str.lower()}\" return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() ) @classmethod def default_filename(cls) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\" @classmethod def default_filepath(cls) -> PathOpt: \"\"\" Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. \"\"\" return Path.home() / cls.default_foldername() / cls.default_filename() @classmethod def set_filepath(cls, file_path: PathOrStr = \"\", load: bool = False) -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) if load: cls.load() else: if cls._get() is not None: print( f\"Warning: filepath has been set the but file is not loaded into the {cls.kind_string()}.\" ) @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath()) @classmethod def load(cls, throw_if_file_not_found: bool = False) -> Self: \"\"\"Create a new singleton\"\"\" return cls._create_instance(throw_if_file_not_found) @classmethod def _create_instance(cls, throw_if_file_not_found: bool = False) -> Self: \"\"\"Load stored data, instantiate the Container with it, store it in the singleton and return it.\"\"\" # get whatever is stored in the config/settings file data_stored = cls._get_saved_data(throw_if_file_not_found) # instantiate and store the Container with the stored data return cls.set(data_stored) def _update(self, changes: dict[str, Any]) -> Self: \"Update and save the settings with data specified in changes; not meant for config\" return ( super() # pylint: disable=protected-access,no-member ._update(changes) ._save() ) def _save(self) -> Self: \"\"\"Private method to save the singleton to file.\"\"\" if path := self.filepath(): path.parent.mkdir(parents=True, exist_ok=True) if (ext := path.suffix[1:].lower()) == FileFormat.TOML.value: with path.open(mode=\"wb\") as fptr: tomli_w.dump(asdict(self), fptr) elif ext == FileFormat.JSON.value: with path.open(mode=\"w\") as fptr: json.dump(asdict(self), fptr) else: print(f\"Unknown file format {ext} given in {path}.\") else: # This situation can occur if no valid path was given as an argument, and # the default path is set to None. raise RuntimeError( f\"No path specified for {self.kind_string().lower()} file, cannot be saved.\" ) return self @classmethod def _get_saved_data(cls, throw_if_file_not_found: bool = False) -> dict[str, Any]: \"\"\"Get the data stored in the parameter file\"\"\" data_stored: dict[str, Any] = {} path = cls.filepath() if path is None or not path.is_file(): err_mess = ( f\"Path {str(path)} not valid for {cls.kind_string().lower()} file.\" ) if throw_if_file_not_found: raise FileNotFoundError(err_mess) print(err_mess, \"Trying with defaults, but this may not work.\") return {} if (ext := path.suffix[1:].lower()) == str(FileFormat.TOML.value): with path.open(mode=\"rb\") as fptr: data_stored = tomllib.load(fptr) elif ext == str(FileFormat.JSON.value): with path.open(mode=\"r\") as fptr: data_stored = json.load(fptr) else: print(f\"Unknown file format {ext} given in {path}.\") return data_stored _ALL_PATHS: dict[int, PathOpt] = {}","title":"Module application_settings.container_base"},{"location":"reference/application_settings/container_base/#classes","text":"","title":"Classes"},{"location":"reference/application_settings/container_base/#containerbase","text":"class ContainerBase ( ) Base class for Config and Settings container classes ??? example \"View Source\" @dataclass(frozen=True) class ContainerBase(ContainerSectionBase, ABC): \"\"\"Base class for Config and Settings container classes\"\"\" @classmethod @abstractmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" @classmethod def default_foldername(cls) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" if (kind_str := cls.kind_string()) == cls.__name__: return f\".{kind_str.lower()}\" return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() ) @classmethod def default_filename(cls) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\" @classmethod def default_filepath(cls) -> PathOpt: \"\"\" Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. \"\"\" return Path.home() / cls.default_foldername() / cls.default_filename() @classmethod def set_filepath(cls, file_path: PathOrStr = \"\", load: bool = False) -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) if load: cls.load() else: if cls._get() is not None: print( f\"Warning: filepath has been set the but file is not loaded into the {cls.kind_string()}.\" ) @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath()) @classmethod def load(cls, throw_if_file_not_found: bool = False) -> Self: \"\"\"Create a new singleton\"\"\" return cls._create_instance(throw_if_file_not_found) @classmethod def _create_instance(cls, throw_if_file_not_found: bool = False) -> Self: \"\"\"Load stored data, instantiate the Container with it, store it in the singleton and return it.\"\"\" # get whatever is stored in the config/settings file data_stored = cls._get_saved_data(throw_if_file_not_found) # instantiate and store the Container with the stored data return cls.set(data_stored) def _update(self, changes: dict[str, Any]) -> Self: \"Update and save the settings with data specified in changes; not meant for config\" return ( super() # pylint: disable=protected-access,no-member ._update(changes) ._save() ) def _save(self) -> Self: \"\"\"Private method to save the singleton to file.\"\"\" if path := self.filepath(): path.parent.mkdir(parents=True, exist_ok=True) if (ext := path.suffix[1:].lower()) == FileFormat.TOML.value: with path.open(mode=\"wb\") as fptr: tomli_w.dump(asdict(self), fptr) elif ext == FileFormat.JSON.value: with path.open(mode=\"w\") as fptr: json.dump(asdict(self), fptr) else: print(f\"Unknown file format {ext} given in {path}.\") else: # This situation can occur if no valid path was given as an argument, and # the default path is set to None. raise RuntimeError( f\"No path specified for {self.kind_string().lower()} file, cannot be saved.\" ) return self @classmethod def _get_saved_data(cls, throw_if_file_not_found: bool = False) -> dict[str, Any]: \"\"\"Get the data stored in the parameter file\"\"\" data_stored: dict[str, Any] = {} path = cls.filepath() if path is None or not path.is_file(): err_mess = ( f\"Path {str(path)} not valid for {cls.kind_string().lower()} file.\" ) if throw_if_file_not_found: raise FileNotFoundError(err_mess) print(err_mess, \"Trying with defaults, but this may not work.\") return {} if (ext := path.suffix[1:].lower()) == str(FileFormat.TOML.value): with path.open(mode=\"rb\") as fptr: data_stored = tomllib.load(fptr) elif ext == str(FileFormat.JSON.value): with path.open(mode=\"r\") as fptr: data_stored = json.load(fptr) else: print(f\"Unknown file format {ext} given in {path}.\") return data_stored","title":"ContainerBase"},{"location":"reference/application_settings/container_base/#ancestors-in-mro","text":"application_settings.container_section_base.ContainerSectionBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/application_settings/container_base/#descendants","text":"application_settings.configuring_base.ConfigBase application_settings.settings_base.SettingsBase","title":"Descendants"},{"location":"reference/application_settings/container_base/#static-methods","text":"","title":"Static methods"},{"location":"reference/application_settings/container_base/#default_file_format","text":"def default_file_format ( ) -> application_settings . container_base . FileFormat Return the default file format ??? example \"View Source\" @classmethod @abstractmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\"","title":"default_file_format"},{"location":"reference/application_settings/container_base/#default_filename","text":"def default_filename ( ) -> str Return the kind_string, lowercase, with the extension that fits the file_format. ??? example \"View Source\" @classmethod def default_filename(cls) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\"","title":"default_filename"},{"location":"reference/application_settings/container_base/#default_filepath","text":"def default_filepath ( ) -> pathlib . Path | None Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. ??? example \"View Source\" @classmethod def default_filepath(cls) -> PathOpt: \"\"\" Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. \"\"\" return Path.home() / cls.default_foldername() / cls.default_filename()","title":"default_filepath"},{"location":"reference/application_settings/container_base/#default_foldername","text":"def default_foldername ( ) -> str Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words. ??? example \"View Source\" @classmethod def default_foldername(cls) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" if (kind_str := cls.kind_string()) == cls.__name__: return f\".{kind_str.lower()}\" return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() )","title":"default_foldername"},{"location":"reference/application_settings/container_base/#filepath","text":"def filepath ( ) -> pathlib . Path | None Return the path for the file that holds the config / settings. ??? example \"View Source\" @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath())","title":"filepath"},{"location":"reference/application_settings/container_base/#get","text":"def get ( ) -> Self Get the singleton; if not existing, create it. Reading file only done for a container. ??? example \"View Source\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none","title":"get"},{"location":"reference/application_settings/container_base/#kind_string","text":"def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return either 'Config' or 'Settings' ??? example \"View Source\" @classmethod @abstractmethod def kind_string(cls) -> SectionTypeStr: \"Return either 'Config' or 'Settings'\"","title":"kind_string"},{"location":"reference/application_settings/container_base/#load","text":"def load ( throw_if_file_not_found : bool = False ) -> Self Create a new singleton ??? example \"View Source\" @classmethod def load(cls, throw_if_file_not_found: bool = False) -> Self: \"\"\"Create a new singleton\"\"\" return cls._create_instance(throw_if_file_not_found)","title":"load"},{"location":"reference/application_settings/container_base/#set","text":"def set ( data : dict [ str , typing . Any ] ) -> Self Create a new dataclass instance using data and set the singleton. ??? example \"View Source\" @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set()","title":"set"},{"location":"reference/application_settings/container_base/#set_filepath","text":"def set_filepath ( file_path : pathlib . Path | str = '' , load : bool = False ) -> None Set the path for the file (a singleton). ??? example \"View Source\" @classmethod def set_filepath(cls, file_path: PathOrStr = \"\", load: bool = False) -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) if load: cls.load() else: if cls._get() is not None: print( f\"Warning: filepath has been set the but file is not loaded into the {cls.kind_string()}.\" )","title":"set_filepath"},{"location":"reference/application_settings/container_base/#update","text":"def update ( changes : dict [ str , typing . Any ] ) -> Self Update the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update(cls, changes: dict[str, Any]) -> Self: \"Update the settings with data specified in changes; not meant for config\" return cls.get()._update(changes)._set() # pylint: disable=protected-access","title":"update"},{"location":"reference/application_settings/container_base/#fileformat","text":"class FileFormat ( * args , ** kwds ) File formats that are supported by application_settings ??? example \"View Source\" @unique class FileFormat(Enum): \"File formats that are supported by application_settings\" TOML = \"toml\" JSON = \"json\"","title":"FileFormat"},{"location":"reference/application_settings/container_base/#ancestors-in-mro_1","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/application_settings/container_base/#class-variables","text":"JSON TOML name value","title":"Class variables"},{"location":"reference/application_settings/container_section_base/","text":"Module application_settings.container_section_base Base class for sections to be added to containers and container sections for configuration and settings. ??? example \"View Source\" \"\"\"Base class for sections to be added to containers and container sections for configuration and settings.\"\"\" import sys from abc import ABC, abstractmethod from dataclasses import replace from typing import Any, Literal, Optional, cast from pydantic.dataclasses import dataclass if sys.version_info >= (3, 11): from typing import Self else: from typing_extensions import Self SectionTypeStr = Literal[\"Config\", \"Settings\"] @dataclass(frozen=True) class ContainerSectionBase(ABC): \"\"\"Base class for all ContainerSection classes\"\"\" @classmethod @abstractmethod def kind_string(cls) -> SectionTypeStr: \"Return either 'Config' or 'Settings'\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set() @classmethod def update(cls, changes: dict[str, Any]) -> Self: \"Update the settings with data specified in changes; not meant for config\" return cls.get()._update(changes)._set() # pylint: disable=protected-access @classmethod def _get( cls, ) -> Optional[Self]: # pylint: disable=consider-alternative-union-syntax \"\"\"Get the singleton.\"\"\" if the_container := _ALL_CONTAINER_SECTION_SINGLETONS.get(id(cls)): return cast(Self, the_container) return None @classmethod def _create_instance( cls, throw_if_file_not_found: bool = False # pylint: disable=unused-argument ) -> Self: \"\"\"Create a new ContainerSection with default values. Likely that this is wrong.\"\"\" # This situation can occur if get() is called on a Section but the application # has not yet created or loaded a config. print( f\"Section {cls.__name__} accessed before data has been set by the application.\" ) return cls().set({}) def _set(self) -> Self: \"\"\"Store the singleton.\"\"\" _ALL_CONTAINER_SECTION_SINGLETONS[id(self.__class__)] = self subsections = [ attr for attr in vars(self).values() if isinstance(attr, ContainerSectionBase) ] for subsec in subsections: subsec._set() # pylint: disable=protected-access return self def _update(self, changes: dict[str, Any]) -> Self: \"Update parameters and sections with data specified in changes; not meant for config\" return replace(self, **changes) _ALL_CONTAINER_SECTION_SINGLETONS: dict[int, ContainerSectionBase] = {} Variables SectionTypeStr Classes ContainerSectionBase class ContainerSectionBase ( ) Base class for all ContainerSection classes ??? example \"View Source\" @dataclass(frozen=True) class ContainerSectionBase(ABC): \"\"\"Base class for all ContainerSection classes\"\"\" @classmethod @abstractmethod def kind_string(cls) -> SectionTypeStr: \"Return either 'Config' or 'Settings'\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set() @classmethod def update(cls, changes: dict[str, Any]) -> Self: \"Update the settings with data specified in changes; not meant for config\" return cls.get()._update(changes)._set() # pylint: disable=protected-access @classmethod def _get( cls, ) -> Optional[Self]: # pylint: disable=consider-alternative-union-syntax \"\"\"Get the singleton.\"\"\" if the_container := _ALL_CONTAINER_SECTION_SINGLETONS.get(id(cls)): return cast(Self, the_container) return None @classmethod def _create_instance( cls, throw_if_file_not_found: bool = False # pylint: disable=unused-argument ) -> Self: \"\"\"Create a new ContainerSection with default values. Likely that this is wrong.\"\"\" # This situation can occur if get() is called on a Section but the application # has not yet created or loaded a config. print( f\"Section {cls.__name__} accessed before data has been set by the application.\" ) return cls().set({}) def _set(self) -> Self: \"\"\"Store the singleton.\"\"\" _ALL_CONTAINER_SECTION_SINGLETONS[id(self.__class__)] = self subsections = [ attr for attr in vars(self).values() if isinstance(attr, ContainerSectionBase) ] for subsec in subsections: subsec._set() # pylint: disable=protected-access return self def _update(self, changes: dict[str, Any]) -> Self: \"Update parameters and sections with data specified in changes; not meant for config\" return replace(self, **changes) Ancestors (in MRO) abc.ABC Descendants application_settings.container_base.ContainerBase application_settings.configuring_base.ConfigSectionBase application_settings.settings_base.SettingsSectionBase Static methods get def get ( ) -> Self Get the singleton; if not existing, create it. Reading file only done for a container. ??? example \"View Source\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none kind_string def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return either 'Config' or 'Settings' ??? example \"View Source\" @classmethod @abstractmethod def kind_string(cls) -> SectionTypeStr: \"Return either 'Config' or 'Settings'\" set def set ( data : dict [ str , typing . Any ] ) -> Self Create a new dataclass instance using data and set the singleton. ??? example \"View Source\" @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set() update def update ( changes : dict [ str , typing . Any ] ) -> Self Update the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update(cls, changes: dict[str, Any]) -> Self: \"Update the settings with data specified in changes; not meant for config\" return cls.get()._update(changes)._set() # pylint: disable=protected-access","title":"Container Section Base"},{"location":"reference/application_settings/container_section_base/#module-application_settingscontainer_section_base","text":"Base class for sections to be added to containers and container sections for configuration and settings. ??? example \"View Source\" \"\"\"Base class for sections to be added to containers and container sections for configuration and settings.\"\"\" import sys from abc import ABC, abstractmethod from dataclasses import replace from typing import Any, Literal, Optional, cast from pydantic.dataclasses import dataclass if sys.version_info >= (3, 11): from typing import Self else: from typing_extensions import Self SectionTypeStr = Literal[\"Config\", \"Settings\"] @dataclass(frozen=True) class ContainerSectionBase(ABC): \"\"\"Base class for all ContainerSection classes\"\"\" @classmethod @abstractmethod def kind_string(cls) -> SectionTypeStr: \"Return either 'Config' or 'Settings'\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set() @classmethod def update(cls, changes: dict[str, Any]) -> Self: \"Update the settings with data specified in changes; not meant for config\" return cls.get()._update(changes)._set() # pylint: disable=protected-access @classmethod def _get( cls, ) -> Optional[Self]: # pylint: disable=consider-alternative-union-syntax \"\"\"Get the singleton.\"\"\" if the_container := _ALL_CONTAINER_SECTION_SINGLETONS.get(id(cls)): return cast(Self, the_container) return None @classmethod def _create_instance( cls, throw_if_file_not_found: bool = False # pylint: disable=unused-argument ) -> Self: \"\"\"Create a new ContainerSection with default values. Likely that this is wrong.\"\"\" # This situation can occur if get() is called on a Section but the application # has not yet created or loaded a config. print( f\"Section {cls.__name__} accessed before data has been set by the application.\" ) return cls().set({}) def _set(self) -> Self: \"\"\"Store the singleton.\"\"\" _ALL_CONTAINER_SECTION_SINGLETONS[id(self.__class__)] = self subsections = [ attr for attr in vars(self).values() if isinstance(attr, ContainerSectionBase) ] for subsec in subsections: subsec._set() # pylint: disable=protected-access return self def _update(self, changes: dict[str, Any]) -> Self: \"Update parameters and sections with data specified in changes; not meant for config\" return replace(self, **changes) _ALL_CONTAINER_SECTION_SINGLETONS: dict[int, ContainerSectionBase] = {}","title":"Module application_settings.container_section_base"},{"location":"reference/application_settings/container_section_base/#variables","text":"SectionTypeStr","title":"Variables"},{"location":"reference/application_settings/container_section_base/#classes","text":"","title":"Classes"},{"location":"reference/application_settings/container_section_base/#containersectionbase","text":"class ContainerSectionBase ( ) Base class for all ContainerSection classes ??? example \"View Source\" @dataclass(frozen=True) class ContainerSectionBase(ABC): \"\"\"Base class for all ContainerSection classes\"\"\" @classmethod @abstractmethod def kind_string(cls) -> SectionTypeStr: \"Return either 'Config' or 'Settings'\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set() @classmethod def update(cls, changes: dict[str, Any]) -> Self: \"Update the settings with data specified in changes; not meant for config\" return cls.get()._update(changes)._set() # pylint: disable=protected-access @classmethod def _get( cls, ) -> Optional[Self]: # pylint: disable=consider-alternative-union-syntax \"\"\"Get the singleton.\"\"\" if the_container := _ALL_CONTAINER_SECTION_SINGLETONS.get(id(cls)): return cast(Self, the_container) return None @classmethod def _create_instance( cls, throw_if_file_not_found: bool = False # pylint: disable=unused-argument ) -> Self: \"\"\"Create a new ContainerSection with default values. Likely that this is wrong.\"\"\" # This situation can occur if get() is called on a Section but the application # has not yet created or loaded a config. print( f\"Section {cls.__name__} accessed before data has been set by the application.\" ) return cls().set({}) def _set(self) -> Self: \"\"\"Store the singleton.\"\"\" _ALL_CONTAINER_SECTION_SINGLETONS[id(self.__class__)] = self subsections = [ attr for attr in vars(self).values() if isinstance(attr, ContainerSectionBase) ] for subsec in subsections: subsec._set() # pylint: disable=protected-access return self def _update(self, changes: dict[str, Any]) -> Self: \"Update parameters and sections with data specified in changes; not meant for config\" return replace(self, **changes)","title":"ContainerSectionBase"},{"location":"reference/application_settings/container_section_base/#ancestors-in-mro","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/application_settings/container_section_base/#descendants","text":"application_settings.container_base.ContainerBase application_settings.configuring_base.ConfigSectionBase application_settings.settings_base.SettingsSectionBase","title":"Descendants"},{"location":"reference/application_settings/container_section_base/#static-methods","text":"","title":"Static methods"},{"location":"reference/application_settings/container_section_base/#get","text":"def get ( ) -> Self Get the singleton; if not existing, create it. Reading file only done for a container. ??? example \"View Source\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none","title":"get"},{"location":"reference/application_settings/container_section_base/#kind_string","text":"def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return either 'Config' or 'Settings' ??? example \"View Source\" @classmethod @abstractmethod def kind_string(cls) -> SectionTypeStr: \"Return either 'Config' or 'Settings'\"","title":"kind_string"},{"location":"reference/application_settings/container_section_base/#set","text":"def set ( data : dict [ str , typing . Any ] ) -> Self Create a new dataclass instance using data and set the singleton. ??? example \"View Source\" @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set()","title":"set"},{"location":"reference/application_settings/container_section_base/#update","text":"def update ( changes : dict [ str , typing . Any ] ) -> Self Update the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update(cls, changes: dict[str, Any]) -> Self: \"Update the settings with data specified in changes; not meant for config\" return cls.get()._update(changes)._set() # pylint: disable=protected-access","title":"update"},{"location":"reference/application_settings/convenience/","text":"Module application_settings.convenience Functions that can be called from the application to make life easy. ??? example \"View Source\" \"\"\"Functions that can be called from the application to make life easy.\"\"\" from argparse import ArgumentParser from pathlib import Path from typing import Union from application_settings.configuring_base import ConfigT from application_settings.settings_base import SettingsT def config_filepath_from_cli( config_class: type[ConfigT], parser: ArgumentParser = ArgumentParser(), short_option: str = \"-c\", long_option: str = \"--config_filepath\", load: bool = False, ) -> ArgumentParser: \"\"\"Add a commandline option for the config file and set filepath if it is given\"\"\" helptext: str = \"Path of the configuration file\" return _parameters_filepath_from_cli( config_class=config_class, settings_class=None, parser=parser, short_option=short_option, long_option=long_option, helptext=helptext, load=load, ) def settings_filepath_from_cli( settings_class: type[SettingsT], parser: ArgumentParser = ArgumentParser(), short_option: str = \"-s\", long_option: str = \"--settings_filepath\", load: bool = False, ) -> ArgumentParser: \"\"\"Add a commandline option for the settings file and set filepath if it is given\"\"\" helptext: str = \"Path of the settings file\" return _parameters_filepath_from_cli( config_class=None, settings_class=settings_class, parser=parser, short_option=short_option, long_option=long_option, helptext=helptext, load=load, ) def parameters_folderpath_from_cli( # pylint: disable=too-many-arguments config_class: type[ConfigT], settings_class: type[SettingsT], parser: ArgumentParser = ArgumentParser(), short_option: str = \"-p\", long_option: str = \"--parameters_folderpath\", load: bool = False, ) -> ArgumentParser: \"\"\"Add a commandline option '--parameters_folderpath' for the common config and settings folder and set filepaths if it is given. Default filenames will be appended to the folderpath for config and settings.\"\"\" helptext: str = \"Common path of the config file and settings file\" return _parameters_filepath_from_cli( config_class=config_class, settings_class=settings_class, parser=parser, short_option=short_option, long_option=long_option, helptext=helptext, load=load, ) def _parameters_filepath_from_cli( # pylint: disable=too-many-arguments config_class: Union[ # pylint: disable=consider-alternative-union-syntax type[ConfigT], None ], settings_class: Union[ # pylint: disable=consider-alternative-union-syntax type[SettingsT], None ], parser: ArgumentParser, short_option: str, long_option: str, helptext: str, load: bool, ) -> ArgumentParser: parser.add_argument( short_option, long_option, nargs=1, default=None, type=Path, help=helptext, ) args, _ = parser.parse_known_args() if cmdline_path := getattr(args, long_option[2:], None): universal_cmdline_path = Path(cmdline_path[0]) if config_class and settings_class: config_class.set_filepath( universal_cmdline_path / config_class.default_filename(), load=load ) settings_class.set_filepath( universal_cmdline_path / settings_class.default_filename(), load=load ) elif config_class: config_class.set_filepath(universal_cmdline_path, load=load) elif settings_class: settings_class.set_filepath(universal_cmdline_path, load=load) return parser Functions config_filepath_from_cli def config_filepath_from_cli ( config_class : type [ ~ ConfigT ], parser : argparse . ArgumentParser = ArgumentParser ( prog = 'portray' , usage = None , description = None , formatter_class =< class ' argparse . HelpFormatter '>, conflict_handler=' error ', add_help=True), short_option : str = '-c' , long_option : str = '--config_filepath' , load : bool = False ) -> argparse . ArgumentParser Add a commandline option for the config file and set filepath if it is given ??? example \"View Source\" def config_filepath_from_cli( config_class: type[ConfigT], parser: ArgumentParser = ArgumentParser(), short_option: str = \"-c\", long_option: str = \"--config_filepath\", load: bool = False, ) -> ArgumentParser: \"\"\"Add a commandline option for the config file and set filepath if it is given\"\"\" helptext: str = \"Path of the configuration file\" return _parameters_filepath_from_cli( config_class=config_class, settings_class=None, parser=parser, short_option=short_option, long_option=long_option, helptext=helptext, load=load, ) parameters_folderpath_from_cli def parameters_folderpath_from_cli ( config_class : type [ ~ ConfigT ], settings_class : type [ ~ SettingsT ], parser : argparse . ArgumentParser = ArgumentParser ( prog = 'portray' , usage = None , description = None , formatter_class =< class ' argparse . HelpFormatter '>, conflict_handler=' error ', add_help=True), short_option : str = '-p' , long_option : str = '--parameters_folderpath' , load : bool = False ) -> argparse . ArgumentParser Add a commandline option '--parameters_folderpath' for the common config and settings folder and set filepaths if it is given. Default filenames will be appended to the folderpath for config and settings. ??? example \"View Source\" def parameters_folderpath_from_cli( # pylint: disable=too-many-arguments config_class: type[ConfigT], settings_class: type[SettingsT], parser: ArgumentParser = ArgumentParser(), short_option: str = \"-p\", long_option: str = \"--parameters_folderpath\", load: bool = False, ) -> ArgumentParser: \"\"\"Add a commandline option '--parameters_folderpath' for the common config and settings folder and set filepaths if it is given. Default filenames will be appended to the folderpath for config and settings.\"\"\" helptext: str = \"Common path of the config file and settings file\" return _parameters_filepath_from_cli( config_class=config_class, settings_class=settings_class, parser=parser, short_option=short_option, long_option=long_option, helptext=helptext, load=load, ) settings_filepath_from_cli def settings_filepath_from_cli ( settings_class : type [ ~ SettingsT ], parser : argparse . ArgumentParser = ArgumentParser ( prog = 'portray' , usage = None , description = None , formatter_class =< class ' argparse . HelpFormatter '>, conflict_handler=' error ', add_help=True), short_option : str = '-s' , long_option : str = '--settings_filepath' , load : bool = False ) -> argparse . ArgumentParser Add a commandline option for the settings file and set filepath if it is given ??? example \"View Source\" def settings_filepath_from_cli( settings_class: type[SettingsT], parser: ArgumentParser = ArgumentParser(), short_option: str = \"-s\", long_option: str = \"--settings_filepath\", load: bool = False, ) -> ArgumentParser: \"\"\"Add a commandline option for the settings file and set filepath if it is given\"\"\" helptext: str = \"Path of the settings file\" return _parameters_filepath_from_cli( config_class=None, settings_class=settings_class, parser=parser, short_option=short_option, long_option=long_option, helptext=helptext, load=load, )","title":"Convenience"},{"location":"reference/application_settings/convenience/#module-application_settingsconvenience","text":"Functions that can be called from the application to make life easy. ??? example \"View Source\" \"\"\"Functions that can be called from the application to make life easy.\"\"\" from argparse import ArgumentParser from pathlib import Path from typing import Union from application_settings.configuring_base import ConfigT from application_settings.settings_base import SettingsT def config_filepath_from_cli( config_class: type[ConfigT], parser: ArgumentParser = ArgumentParser(), short_option: str = \"-c\", long_option: str = \"--config_filepath\", load: bool = False, ) -> ArgumentParser: \"\"\"Add a commandline option for the config file and set filepath if it is given\"\"\" helptext: str = \"Path of the configuration file\" return _parameters_filepath_from_cli( config_class=config_class, settings_class=None, parser=parser, short_option=short_option, long_option=long_option, helptext=helptext, load=load, ) def settings_filepath_from_cli( settings_class: type[SettingsT], parser: ArgumentParser = ArgumentParser(), short_option: str = \"-s\", long_option: str = \"--settings_filepath\", load: bool = False, ) -> ArgumentParser: \"\"\"Add a commandline option for the settings file and set filepath if it is given\"\"\" helptext: str = \"Path of the settings file\" return _parameters_filepath_from_cli( config_class=None, settings_class=settings_class, parser=parser, short_option=short_option, long_option=long_option, helptext=helptext, load=load, ) def parameters_folderpath_from_cli( # pylint: disable=too-many-arguments config_class: type[ConfigT], settings_class: type[SettingsT], parser: ArgumentParser = ArgumentParser(), short_option: str = \"-p\", long_option: str = \"--parameters_folderpath\", load: bool = False, ) -> ArgumentParser: \"\"\"Add a commandline option '--parameters_folderpath' for the common config and settings folder and set filepaths if it is given. Default filenames will be appended to the folderpath for config and settings.\"\"\" helptext: str = \"Common path of the config file and settings file\" return _parameters_filepath_from_cli( config_class=config_class, settings_class=settings_class, parser=parser, short_option=short_option, long_option=long_option, helptext=helptext, load=load, ) def _parameters_filepath_from_cli( # pylint: disable=too-many-arguments config_class: Union[ # pylint: disable=consider-alternative-union-syntax type[ConfigT], None ], settings_class: Union[ # pylint: disable=consider-alternative-union-syntax type[SettingsT], None ], parser: ArgumentParser, short_option: str, long_option: str, helptext: str, load: bool, ) -> ArgumentParser: parser.add_argument( short_option, long_option, nargs=1, default=None, type=Path, help=helptext, ) args, _ = parser.parse_known_args() if cmdline_path := getattr(args, long_option[2:], None): universal_cmdline_path = Path(cmdline_path[0]) if config_class and settings_class: config_class.set_filepath( universal_cmdline_path / config_class.default_filename(), load=load ) settings_class.set_filepath( universal_cmdline_path / settings_class.default_filename(), load=load ) elif config_class: config_class.set_filepath(universal_cmdline_path, load=load) elif settings_class: settings_class.set_filepath(universal_cmdline_path, load=load) return parser","title":"Module application_settings.convenience"},{"location":"reference/application_settings/convenience/#functions","text":"","title":"Functions"},{"location":"reference/application_settings/convenience/#config_filepath_from_cli","text":"def config_filepath_from_cli ( config_class : type [ ~ ConfigT ], parser : argparse . ArgumentParser = ArgumentParser ( prog = 'portray' , usage = None , description = None , formatter_class =< class ' argparse . HelpFormatter '>, conflict_handler=' error ', add_help=True), short_option : str = '-c' , long_option : str = '--config_filepath' , load : bool = False ) -> argparse . ArgumentParser Add a commandline option for the config file and set filepath if it is given ??? example \"View Source\" def config_filepath_from_cli( config_class: type[ConfigT], parser: ArgumentParser = ArgumentParser(), short_option: str = \"-c\", long_option: str = \"--config_filepath\", load: bool = False, ) -> ArgumentParser: \"\"\"Add a commandline option for the config file and set filepath if it is given\"\"\" helptext: str = \"Path of the configuration file\" return _parameters_filepath_from_cli( config_class=config_class, settings_class=None, parser=parser, short_option=short_option, long_option=long_option, helptext=helptext, load=load, )","title":"config_filepath_from_cli"},{"location":"reference/application_settings/convenience/#parameters_folderpath_from_cli","text":"def parameters_folderpath_from_cli ( config_class : type [ ~ ConfigT ], settings_class : type [ ~ SettingsT ], parser : argparse . ArgumentParser = ArgumentParser ( prog = 'portray' , usage = None , description = None , formatter_class =< class ' argparse . HelpFormatter '>, conflict_handler=' error ', add_help=True), short_option : str = '-p' , long_option : str = '--parameters_folderpath' , load : bool = False ) -> argparse . ArgumentParser Add a commandline option '--parameters_folderpath' for the common config and settings folder and set filepaths if it is given. Default filenames will be appended to the folderpath for config and settings. ??? example \"View Source\" def parameters_folderpath_from_cli( # pylint: disable=too-many-arguments config_class: type[ConfigT], settings_class: type[SettingsT], parser: ArgumentParser = ArgumentParser(), short_option: str = \"-p\", long_option: str = \"--parameters_folderpath\", load: bool = False, ) -> ArgumentParser: \"\"\"Add a commandline option '--parameters_folderpath' for the common config and settings folder and set filepaths if it is given. Default filenames will be appended to the folderpath for config and settings.\"\"\" helptext: str = \"Common path of the config file and settings file\" return _parameters_filepath_from_cli( config_class=config_class, settings_class=settings_class, parser=parser, short_option=short_option, long_option=long_option, helptext=helptext, load=load, )","title":"parameters_folderpath_from_cli"},{"location":"reference/application_settings/convenience/#settings_filepath_from_cli","text":"def settings_filepath_from_cli ( settings_class : type [ ~ SettingsT ], parser : argparse . ArgumentParser = ArgumentParser ( prog = 'portray' , usage = None , description = None , formatter_class =< class ' argparse . HelpFormatter '>, conflict_handler=' error ', add_help=True), short_option : str = '-s' , long_option : str = '--settings_filepath' , load : bool = False ) -> argparse . ArgumentParser Add a commandline option for the settings file and set filepath if it is given ??? example \"View Source\" def settings_filepath_from_cli( settings_class: type[SettingsT], parser: ArgumentParser = ArgumentParser(), short_option: str = \"-s\", long_option: str = \"--settings_filepath\", load: bool = False, ) -> ArgumentParser: \"\"\"Add a commandline option for the settings file and set filepath if it is given\"\"\" helptext: str = \"Path of the settings file\" return _parameters_filepath_from_cli( config_class=None, settings_class=settings_class, parser=parser, short_option=short_option, long_option=long_option, helptext=helptext, load=load, )","title":"settings_filepath_from_cli"},{"location":"reference/application_settings/settings_base/","text":"Module application_settings.settings_base Module for handling settings. ??? example \"View Source\" \"\"\"Module for handling settings.\"\"\" from typing import TypeVar from pydantic.dataclasses import dataclass from application_settings.container_base import ContainerBase, FileFormat from application_settings.container_section_base import ( ContainerSectionBase, SectionTypeStr, ) SettingsT = TypeVar(\"SettingsT\", bound=\"SettingsBase\") SettingsT.__doc__ = \"Represents SettingsBase and all subclasses\" @dataclass(frozen=True) class SettingsSectionBase(ContainerSectionBase): \"\"\"Base class for all SettingsSection classes (so that we can bound a TypeVar)\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Settings'\" return \"Settings\" @dataclass(frozen=True) class SettingsBase(ContainerBase): \"\"\"Base class for main Settings class\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Settings'\" return \"Settings\" @classmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" return FileFormat.JSON Variables SettingsT Classes SettingsBase class SettingsBase ( ) Base class for main Settings class ??? example \"View Source\" @dataclass(frozen=True) class SettingsBase(ContainerBase): \"\"\"Base class for main Settings class\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Settings'\" return \"Settings\" @classmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" return FileFormat.JSON Ancestors (in MRO) application_settings.container_base.ContainerBase application_settings.container_section_base.ContainerSectionBase abc.ABC Static methods default_file_format def default_file_format ( ) -> application_settings . container_base . FileFormat Return the default file format ??? example \"View Source\" @classmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" return FileFormat.JSON default_filename def default_filename ( ) -> str Return the kind_string, lowercase, with the extension that fits the file_format. ??? example \"View Source\" @classmethod def default_filename(cls) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\" default_filepath def default_filepath ( ) -> pathlib . Path | None Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. ??? example \"View Source\" @classmethod def default_filepath(cls) -> PathOpt: \"\"\" Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. \"\"\" return Path.home() / cls.default_foldername() / cls.default_filename() default_foldername def default_foldername ( ) -> str Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words. ??? example \"View Source\" @classmethod def default_foldername(cls) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" if (kind_str := cls.kind_string()) == cls.__name__: return f\".{kind_str.lower()}\" return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() ) filepath def filepath ( ) -> pathlib . Path | None Return the path for the file that holds the config / settings. ??? example \"View Source\" @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath()) get def get ( ) -> Self Get the singleton; if not existing, create it. Reading file only done for a container. ??? example \"View Source\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none kind_string def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Settings' ??? example \"View Source\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Settings'\" return \"Settings\" load def load ( throw_if_file_not_found : bool = False ) -> Self Create a new singleton ??? example \"View Source\" @classmethod def load(cls, throw_if_file_not_found: bool = False) -> Self: \"\"\"Create a new singleton\"\"\" return cls._create_instance(throw_if_file_not_found) set def set ( data : dict [ str , typing . Any ] ) -> Self Create a new dataclass instance using data and set the singleton. ??? example \"View Source\" @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set() set_filepath def set_filepath ( file_path : pathlib . Path | str = '' , load : bool = False ) -> None Set the path for the file (a singleton). ??? example \"View Source\" @classmethod def set_filepath(cls, file_path: PathOrStr = \"\", load: bool = False) -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) if load: cls.load() else: if cls._get() is not None: print( f\"Warning: filepath has been set the but file is not loaded into the {cls.kind_string()}.\" ) update def update ( changes : dict [ str , typing . Any ] ) -> Self Update the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update(cls, changes: dict[str, Any]) -> Self: \"Update the settings with data specified in changes; not meant for config\" return cls.get()._update(changes)._set() # pylint: disable=protected-access SettingsSectionBase class SettingsSectionBase ( ) Base class for all SettingsSection classes (so that we can bound a TypeVar) ??? example \"View Source\" @dataclass(frozen=True) class SettingsSectionBase(ContainerSectionBase): \"\"\"Base class for all SettingsSection classes (so that we can bound a TypeVar)\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Settings'\" return \"Settings\" Ancestors (in MRO) application_settings.container_section_base.ContainerSectionBase abc.ABC Static methods get def get ( ) -> Self Get the singleton; if not existing, create it. Reading file only done for a container. ??? example \"View Source\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none kind_string def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Settings' ??? example \"View Source\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Settings'\" return \"Settings\" set def set ( data : dict [ str , typing . Any ] ) -> Self Create a new dataclass instance using data and set the singleton. ??? example \"View Source\" @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set() update def update ( changes : dict [ str , typing . Any ] ) -> Self Update the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update(cls, changes: dict[str, Any]) -> Self: \"Update the settings with data specified in changes; not meant for config\" return cls.get()._update(changes)._set() # pylint: disable=protected-access","title":"Settings Base"},{"location":"reference/application_settings/settings_base/#module-application_settingssettings_base","text":"Module for handling settings. ??? example \"View Source\" \"\"\"Module for handling settings.\"\"\" from typing import TypeVar from pydantic.dataclasses import dataclass from application_settings.container_base import ContainerBase, FileFormat from application_settings.container_section_base import ( ContainerSectionBase, SectionTypeStr, ) SettingsT = TypeVar(\"SettingsT\", bound=\"SettingsBase\") SettingsT.__doc__ = \"Represents SettingsBase and all subclasses\" @dataclass(frozen=True) class SettingsSectionBase(ContainerSectionBase): \"\"\"Base class for all SettingsSection classes (so that we can bound a TypeVar)\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Settings'\" return \"Settings\" @dataclass(frozen=True) class SettingsBase(ContainerBase): \"\"\"Base class for main Settings class\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Settings'\" return \"Settings\" @classmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" return FileFormat.JSON","title":"Module application_settings.settings_base"},{"location":"reference/application_settings/settings_base/#variables","text":"SettingsT","title":"Variables"},{"location":"reference/application_settings/settings_base/#classes","text":"","title":"Classes"},{"location":"reference/application_settings/settings_base/#settingsbase","text":"class SettingsBase ( ) Base class for main Settings class ??? example \"View Source\" @dataclass(frozen=True) class SettingsBase(ContainerBase): \"\"\"Base class for main Settings class\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Settings'\" return \"Settings\" @classmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" return FileFormat.JSON","title":"SettingsBase"},{"location":"reference/application_settings/settings_base/#ancestors-in-mro","text":"application_settings.container_base.ContainerBase application_settings.container_section_base.ContainerSectionBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/application_settings/settings_base/#static-methods","text":"","title":"Static methods"},{"location":"reference/application_settings/settings_base/#default_file_format","text":"def default_file_format ( ) -> application_settings . container_base . FileFormat Return the default file format ??? example \"View Source\" @classmethod def default_file_format(cls) -> FileFormat: \"Return the default file format\" return FileFormat.JSON","title":"default_file_format"},{"location":"reference/application_settings/settings_base/#default_filename","text":"def default_filename ( ) -> str Return the kind_string, lowercase, with the extension that fits the file_format. ??? example \"View Source\" @classmethod def default_filename(cls) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\"","title":"default_filename"},{"location":"reference/application_settings/settings_base/#default_filepath","text":"def default_filepath ( ) -> pathlib . Path | None Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. ??? example \"View Source\" @classmethod def default_filepath(cls) -> PathOpt: \"\"\" Return the fully qualified default path for the config/settingsfile: e.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None. \"\"\" return Path.home() / cls.default_foldername() / cls.default_filename()","title":"default_filepath"},{"location":"reference/application_settings/settings_base/#default_foldername","text":"def default_foldername ( ) -> str Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words. ??? example \"View Source\" @classmethod def default_foldername(cls) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" if (kind_str := cls.kind_string()) == cls.__name__: return f\".{kind_str.lower()}\" return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() )","title":"default_foldername"},{"location":"reference/application_settings/settings_base/#filepath","text":"def filepath ( ) -> pathlib . Path | None Return the path for the file that holds the config / settings. ??? example \"View Source\" @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath())","title":"filepath"},{"location":"reference/application_settings/settings_base/#get","text":"def get ( ) -> Self Get the singleton; if not existing, create it. Reading file only done for a container. ??? example \"View Source\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none","title":"get"},{"location":"reference/application_settings/settings_base/#kind_string","text":"def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Settings' ??? example \"View Source\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Settings'\" return \"Settings\"","title":"kind_string"},{"location":"reference/application_settings/settings_base/#load","text":"def load ( throw_if_file_not_found : bool = False ) -> Self Create a new singleton ??? example \"View Source\" @classmethod def load(cls, throw_if_file_not_found: bool = False) -> Self: \"\"\"Create a new singleton\"\"\" return cls._create_instance(throw_if_file_not_found)","title":"load"},{"location":"reference/application_settings/settings_base/#set","text":"def set ( data : dict [ str , typing . Any ] ) -> Self Create a new dataclass instance using data and set the singleton. ??? example \"View Source\" @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set()","title":"set"},{"location":"reference/application_settings/settings_base/#set_filepath","text":"def set_filepath ( file_path : pathlib . Path | str = '' , load : bool = False ) -> None Set the path for the file (a singleton). ??? example \"View Source\" @classmethod def set_filepath(cls, file_path: PathOrStr = \"\", load: bool = False) -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) if load: cls.load() else: if cls._get() is not None: print( f\"Warning: filepath has been set the but file is not loaded into the {cls.kind_string()}.\" )","title":"set_filepath"},{"location":"reference/application_settings/settings_base/#update","text":"def update ( changes : dict [ str , typing . Any ] ) -> Self Update the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update(cls, changes: dict[str, Any]) -> Self: \"Update the settings with data specified in changes; not meant for config\" return cls.get()._update(changes)._set() # pylint: disable=protected-access","title":"update"},{"location":"reference/application_settings/settings_base/#settingssectionbase","text":"class SettingsSectionBase ( ) Base class for all SettingsSection classes (so that we can bound a TypeVar) ??? example \"View Source\" @dataclass(frozen=True) class SettingsSectionBase(ContainerSectionBase): \"\"\"Base class for all SettingsSection classes (so that we can bound a TypeVar)\"\"\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Settings'\" return \"Settings\"","title":"SettingsSectionBase"},{"location":"reference/application_settings/settings_base/#ancestors-in-mro_1","text":"application_settings.container_section_base.ContainerSectionBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/application_settings/settings_base/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/application_settings/settings_base/#get_1","text":"def get ( ) -> Self Get the singleton; if not existing, create it. Reading file only done for a container. ??? example \"View Source\" @classmethod def get(cls) -> Self: \"\"\"Get the singleton; if not existing, create it. Reading file only done for a container.\"\"\" if (_the_container_or_none := cls._get()) is None: # no config section has been made yet, # so let's instantiate one and keep it in the global store return cls._create_instance() return _the_container_or_none","title":"get"},{"location":"reference/application_settings/settings_base/#kind_string_1","text":"def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Settings' ??? example \"View Source\" @classmethod def kind_string(cls) -> SectionTypeStr: \"Return 'Settings'\" return \"Settings\"","title":"kind_string"},{"location":"reference/application_settings/settings_base/#set_1","text":"def set ( data : dict [ str , typing . Any ] ) -> Self Create a new dataclass instance using data and set the singleton. ??? example \"View Source\" @classmethod def set(cls, data: dict[str, Any]) -> Self: \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\" return cls(**data)._set()","title":"set"},{"location":"reference/application_settings/settings_base/#update_1","text":"def update ( changes : dict [ str , typing . Any ] ) -> Self Update the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update(cls, changes: dict[str, Any]) -> Self: \"Update the settings with data specified in changes; not meant for config\" return cls.get()._update(changes)._set() # pylint: disable=protected-access","title":"update"},{"location":"reference/application_settings/type_notation_helper/","text":"Module application_settings.type_notation_helper Defines type aliasses that handle notational differences between python versions. ??? example \"View Source\" # pylint: disable=consider-alternative-union-syntax, useless-suppression \"\"\"Defines type aliasses that handle notational differences between python versions.\"\"\" import sys from pathlib import Path if sys.version_info >= (3, 10): from typing import TypeAlias PathOrStr: TypeAlias = Path | str PathOpt: TypeAlias = Path | None else: from typing import Union from typing_extensions import TypeAlias PathOrStr: TypeAlias = Union[Path, str] PathOpt: TypeAlias = Union[Path, None]","title":"Type Notation Helper"},{"location":"reference/application_settings/type_notation_helper/#module-application_settingstype_notation_helper","text":"Defines type aliasses that handle notational differences between python versions. ??? example \"View Source\" # pylint: disable=consider-alternative-union-syntax, useless-suppression \"\"\"Defines type aliasses that handle notational differences between python versions.\"\"\" import sys from pathlib import Path if sys.version_info >= (3, 10): from typing import TypeAlias PathOrStr: TypeAlias = Path | str PathOpt: TypeAlias = Path | None else: from typing import Union from typing_extensions import TypeAlias PathOrStr: TypeAlias = Union[Path, str] PathOpt: TypeAlias = Union[Path, None]","title":"Module application_settings.type_notation_helper"}]}