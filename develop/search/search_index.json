{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"application_settings \"You write the dataclasses to define parameters for configuration and settings, application_settings takes care of the logic.\" What and why Application_settings is a package for providing a python application with parameters for configuration and settings. It uses toml or json files that are parsed into dataclasses. This brings some benefits: Minimal work for the application designer Parameters are typed, which allows for improved static code analyses. IDEs will provide helpful hints and completion when using the parameters. More control over what happens when a file contains mistakes (by leveraging the power of pydantic ). Possibility to specify defaults when no file is found or entries are missing. Configuration parameters are read-only (i.e., changed by editing the config file); we recommend (and support) the use of toml for this, which is a human-oriented, flexible, standardardized and not overly complex format. Settings parameters are read-write (i.e., mostly changed via the UI of the application); we recommend (and support) use json for this, an established standardized machine-oriented format. Parsing is done once during first access and the resulting set of parameters is stored as a singleton. Interested? Then have a look at our quick start . License This project is licensed under the terms of the MIT license.","title":"Home"},{"location":"#application_settings","text":"\"You write the dataclasses to define parameters for configuration and settings, application_settings takes care of the logic.\"","title":"application_settings"},{"location":"#what-and-why","text":"Application_settings is a package for providing a python application with parameters for configuration and settings. It uses toml or json files that are parsed into dataclasses. This brings some benefits: Minimal work for the application designer Parameters are typed, which allows for improved static code analyses. IDEs will provide helpful hints and completion when using the parameters. More control over what happens when a file contains mistakes (by leveraging the power of pydantic ). Possibility to specify defaults when no file is found or entries are missing. Configuration parameters are read-only (i.e., changed by editing the config file); we recommend (and support) the use of toml for this, which is a human-oriented, flexible, standardardized and not overly complex format. Settings parameters are read-write (i.e., mostly changed via the UI of the application); we recommend (and support) use json for this, an established standardized machine-oriented format. Parsing is done once during first access and the resulting set of parameters is stored as a singleton. Interested? Then have a look at our quick start .","title":"What and why"},{"location":"#license","text":"This project is licensed under the terms of the MIT license.","title":"License"},{"location":"CHANGELOG/","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . [0.2.0] - 2023-03-19 Added Files can be formatted as toml or json . Introduced settings, i.e., read-write parameters (where config is read-only) Now also useable with python 3.9 Documentation extended and served on Github Pages Changed File path for config / settings now via set_filepath() and no longer as argument of get() . [0.1.0] - 2023-02-13 Added Loading a toml file. Initializing a dataclass with the loaded toml and storing it as a singleton. Default path, folder and file name. Specification of a config file path via argument of get() . Validation using pydantic. README that explains it all.","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"CHANGELOG/#020-2023-03-19","text":"","title":"[0.2.0] - 2023-03-19"},{"location":"CHANGELOG/#added","text":"Files can be formatted as toml or json . Introduced settings, i.e., read-write parameters (where config is read-only) Now also useable with python 3.9 Documentation extended and served on Github Pages","title":"Added"},{"location":"CHANGELOG/#changed","text":"File path for config / settings now via set_filepath() and no longer as argument of get() .","title":"Changed"},{"location":"CHANGELOG/#010-2023-02-13","text":"","title":"[0.1.0] - 2023-02-13"},{"location":"CHANGELOG/#added_1","text":"Loading a toml file. Initializing a dataclass with the loaded toml and storing it as a singleton. Default path, folder and file name. Specification of a config file path via argument of get() . Validation using pydantic. README that explains it all.","title":"Added"},{"location":"CODE_OF_CONDUCT/","text":"Contributor Covenant Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at stockwatchdevs@gmail.com. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Contributor Covenant Code of Conduct"},{"location":"CODE_OF_CONDUCT/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"CODE_OF_CONDUCT/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"CODE_OF_CONDUCT/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"CODE_OF_CONDUCT/#scope","text":"This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"CODE_OF_CONDUCT/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at stockwatchdevs@gmail.com. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"CODE_OF_CONDUCT/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"docs/1-Installation/","text":"Install the package application_settings is available on pypi and can hence be installed with pip : On Linux: python -m pip install -U application_settings On Windows: py -m pip install -U application_settings We have a dependency on the following packages: pathvalidate pydantic tomli (for python versions below 3.11) tomli-w This package is not available on conda . If you don't want to wait for a release and prefer to try the develop version, then you can install from our repo: On Linux: python -m pip install git+git://github.com/StockwatchDev/application_settings@develop#egg=application_settings On Windows: py -m pip install git+git://github.com/StockwatchDev/application_settings@develop#egg=application_settings","title":"1. Installation"},{"location":"docs/1-Installation/#install-the-package","text":"application_settings is available on pypi and can hence be installed with pip : On Linux: python -m pip install -U application_settings On Windows: py -m pip install -U application_settings We have a dependency on the following packages: pathvalidate pydantic tomli (for python versions below 3.11) tomli-w This package is not available on conda . If you don't want to wait for a release and prefer to try the develop version, then you can install from our repo: On Linux: python -m pip install git+git://github.com/StockwatchDev/application_settings@develop#egg=application_settings On Windows: py -m pip install git+git://github.com/StockwatchDev/application_settings@develop#egg=application_settings","title":"Install the package"},{"location":"docs/2-Defining_parameters/","text":"The expected way of work is that parameters are defined in section classes and sections are gathered in a container. Defining section(s) A section is defined by subclassing the relevant base class (ConfigSectionBase for config, SettingsSectionBase for settings) and decorating it with @dataclass(frozen=True) . Parameters are defined as fields of the dataclass. For a dataclass, it is mandatory to add a type hint for each field. These type hints are used also to validate the data that is read from the parameter file (because we are using pydantic dataclasses ). If you specify a default value as well, then you prevent the occurance of an exception if the value for the parameter of concern is not found in the parameter file. Defining the container Likewise, the container is defined by subclassing the relevant base class (ConfigBase for config, SettingsBase for settings) and decorating it with @dataclass(frozen=True) . Sections are now defined as fields of this dataclass, type hinted with the appropriate section class and instantiated (possible only when all parameters of the section have default values). Note that albeit settings can be changed programmatically, we still set frozen=True for the settings container and -sections (see also the section below). Example Configuration Settings from application_settings import ( ConfigBase , ConfigSectionBase , ) from pydantic.dataclasses import dataclass @dataclass ( frozen = True ) class MyExampleConfigSection ( ConfigSectionBase ): \"\"\"Config section for an example\"\"\" field1 : str = \"field1\" field2 : int = 2 @dataclass ( frozen = True ) class MyExampleConfig ( ConfigBase ): \"\"\"Config for an example\"\"\" section1 : MyExampleConfigSection = MyExampleConfigSection () from application_settings import ( SettingsBase , SettingsSectionBase , ) from pydantic.dataclasses import dataclass @dataclass ( frozen = True ) class BasicSettingsSection ( SettingsSectionBase ): \"\"\"Settings section for the basics\"\"\" name : str = \"the name\" totals : int = 2 @dataclass ( frozen = True ) class MyExampleSettings ( SettingsBase ): \"\"\"Settings for an example\"\"\" basics : BasicSettingsSection = BasicSettingsSection ()","title":"2. Defining parameters"},{"location":"docs/2-Defining_parameters/#defining-sections","text":"A section is defined by subclassing the relevant base class (ConfigSectionBase for config, SettingsSectionBase for settings) and decorating it with @dataclass(frozen=True) . Parameters are defined as fields of the dataclass. For a dataclass, it is mandatory to add a type hint for each field. These type hints are used also to validate the data that is read from the parameter file (because we are using pydantic dataclasses ). If you specify a default value as well, then you prevent the occurance of an exception if the value for the parameter of concern is not found in the parameter file.","title":"Defining section(s)"},{"location":"docs/2-Defining_parameters/#defining-the-container","text":"Likewise, the container is defined by subclassing the relevant base class (ConfigBase for config, SettingsBase for settings) and decorating it with @dataclass(frozen=True) . Sections are now defined as fields of this dataclass, type hinted with the appropriate section class and instantiated (possible only when all parameters of the section have default values). Note that albeit settings can be changed programmatically, we still set frozen=True for the settings container and -sections (see also the section below).","title":"Defining the container"},{"location":"docs/2-Defining_parameters/#example","text":"Configuration Settings from application_settings import ( ConfigBase , ConfigSectionBase , ) from pydantic.dataclasses import dataclass @dataclass ( frozen = True ) class MyExampleConfigSection ( ConfigSectionBase ): \"\"\"Config section for an example\"\"\" field1 : str = \"field1\" field2 : int = 2 @dataclass ( frozen = True ) class MyExampleConfig ( ConfigBase ): \"\"\"Config for an example\"\"\" section1 : MyExampleConfigSection = MyExampleConfigSection () from application_settings import ( SettingsBase , SettingsSectionBase , ) from pydantic.dataclasses import dataclass @dataclass ( frozen = True ) class BasicSettingsSection ( SettingsSectionBase ): \"\"\"Settings section for the basics\"\"\" name : str = \"the name\" totals : int = 2 @dataclass ( frozen = True ) class MyExampleSettings ( SettingsBase ): \"\"\"Settings for an example\"\"\" basics : BasicSettingsSection = BasicSettingsSection ()","title":"Example"},{"location":"docs/3-Files/","text":"Files for storing parameters Currently, two formats are supported for persistent storage of parameters: toml and json . The toml format is human-oriented, flexible, standardardized and not overly complex. It supports comments, and hence parameters can be easily documented in a toml file. However, when parameters are initialized by reading from a toml file, then changed (because it concerns settings) and subsequently written to file again for persistance, the comments will be lost. Therefore, it does not make much sense to add documenting comments to a settings file. Because config parameters are read-only, comments in a config file will not get lost and do make sense. Because of this, the default format for storing config parameters is toml . The name of a config file equals config.toml by default. JSON is a standardized, lightweight data-interchange format that is easy for machines to parse and generate. It is a bit less straightforward to document parameters in this format, which makes it less human-oriented than toml , but it is used widely for data interchange between automated systems. Because of this, the default format for storing settings parameters is json . The name of a settings file equals settings.json by default. The examples introduced in the previous section can for example be initialized with the following files. config.toml file for the configuration example settings.json file for the settings example [section1] # Use this section to set the config that you prefer by editing the file # field1 has default value 'field1' field1 = \"my own version of the first field\" # field2 has default value 2 field2 = 22 { \"basics\" : { \"name\" : \"the stored name\" , \"totals\" : 3 } } The fieldnames of a Container class are found as: the section names in the toml file the member names of the root object in the json file The fieldnames of a Section class are found as: the fieldnames inside the corresponding section in the toml file the member names of the object that is the value of the name that represents the section in the json file The order of sections and/or fields in the file does not have to adhere to the order in which fields have been specified in the Container - or Section classes. Presence of sections and/or fields in the files that are not defined in the classes goes by silently. Fields or complete sections defined in the classes can be absent in the files as long as default values have been specified for all fields that have been left out. Location, name and type of the file By default, the config and settings file are located in a subfolder of the home folder of the user running the application. The default name of that subfolder is provided by the default_foldername() method and consists of a dot, followed by a name derived from your container class: the word Config / Settings is removed, underscores are put in front of capitals (except for the first letter) and all letters are made lower case. For example, the Container class MyExampleConfig by default will store its config in ~/.my_example/config.toml . And MyExampleSettings will default to a settings file ~/.my_example/settings.json . If you want the files to be stored in a different location and/or have a different name and/or change the format, then you can use the method set_filepath : # the next statement sets the location, name and format of the settings file # the argument can be eiter a string or a Path MyExampleSettings . set_filepath ( r \"C:\\ProgramData\\testsettings.toml\" ) The extension of the file is used to select the format for parsing and hence has to be either json , JSON , toml or TOML .","title":"3. Files and file location"},{"location":"docs/3-Files/#files-for-storing-parameters","text":"Currently, two formats are supported for persistent storage of parameters: toml and json . The toml format is human-oriented, flexible, standardardized and not overly complex. It supports comments, and hence parameters can be easily documented in a toml file. However, when parameters are initialized by reading from a toml file, then changed (because it concerns settings) and subsequently written to file again for persistance, the comments will be lost. Therefore, it does not make much sense to add documenting comments to a settings file. Because config parameters are read-only, comments in a config file will not get lost and do make sense. Because of this, the default format for storing config parameters is toml . The name of a config file equals config.toml by default. JSON is a standardized, lightweight data-interchange format that is easy for machines to parse and generate. It is a bit less straightforward to document parameters in this format, which makes it less human-oriented than toml , but it is used widely for data interchange between automated systems. Because of this, the default format for storing settings parameters is json . The name of a settings file equals settings.json by default. The examples introduced in the previous section can for example be initialized with the following files. config.toml file for the configuration example settings.json file for the settings example [section1] # Use this section to set the config that you prefer by editing the file # field1 has default value 'field1' field1 = \"my own version of the first field\" # field2 has default value 2 field2 = 22 { \"basics\" : { \"name\" : \"the stored name\" , \"totals\" : 3 } } The fieldnames of a Container class are found as: the section names in the toml file the member names of the root object in the json file The fieldnames of a Section class are found as: the fieldnames inside the corresponding section in the toml file the member names of the object that is the value of the name that represents the section in the json file The order of sections and/or fields in the file does not have to adhere to the order in which fields have been specified in the Container - or Section classes. Presence of sections and/or fields in the files that are not defined in the classes goes by silently. Fields or complete sections defined in the classes can be absent in the files as long as default values have been specified for all fields that have been left out.","title":"Files for storing parameters"},{"location":"docs/3-Files/#location-name-and-type-of-the-file","text":"By default, the config and settings file are located in a subfolder of the home folder of the user running the application. The default name of that subfolder is provided by the default_foldername() method and consists of a dot, followed by a name derived from your container class: the word Config / Settings is removed, underscores are put in front of capitals (except for the first letter) and all letters are made lower case. For example, the Container class MyExampleConfig by default will store its config in ~/.my_example/config.toml . And MyExampleSettings will default to a settings file ~/.my_example/settings.json . If you want the files to be stored in a different location and/or have a different name and/or change the format, then you can use the method set_filepath : # the next statement sets the location, name and format of the settings file # the argument can be eiter a string or a Path MyExampleSettings . set_filepath ( r \"C:\\ProgramData\\testsettings.toml\" ) The extension of the file is used to select the format for parsing and hence has to be either json , JSON , toml or TOML .","title":"Location, name and type of the file"},{"location":"docs/4-Using_parameters/","text":"Use parameters in your code Parameter containers are meant to be instantiated just once and be available globally for the application. Therefore, implementation has been done as follows: The instance of a parameter container is accessed via a class method get() ; The parameter value is then obtained by chaining with the section name and the parameter name; The first invocation of get() will create the container instance, try to read values from file and store it for future access in a private module global (a dictionary with the class id as key); A parameter container should not be instantiated directly by client code (although it is possible to do so, e.g. for testing purposes); If needed, you can set the path for the parameter file before the first invocation of get() . Changing parameter values Parameters are defined as fields of frozen dataclasses. Hence, changing parameter values by means of straightforward assignment will raise an error. Config parameters are meant to be read only. Changing values of such parameters has to be done by editing the config file and restarting your application or reloading the config container. Obviously, settings parameters can also be changed by editing the settings file and restarting the application or reloading the settings container. In addition to that, settings can be changed programmatically by calling a class method update(changes: dict[str, dict[str, Any]) , where the argument changes is a dictionary of dictionaries that specifies the sections (keys of the outer dict) and fields (keys of the inner dicts) that are changed. The method update will replace the stored settings in the private module global with an updated instance and the settings file will be updated as well. So the invocation of get() after update or application restart or reloading will return the changed parameter values. Example Configuration Settings import MyExampleConfig # if the config file is not in the default location, then set the path first MyExampleConfig . set_filepath ( r \"C:\\ProgramData\\MyApp\\config.toml\" ) # the next statement will create the config field1_var : str = MyExampleConfig . get () . section1 . field1 # field1_var == \"my own version of the first field\" # the next statement just gets that same instance field2_var : int = MyExampleConfig . get () . section1 . field2 # field2_var == 22 # if you have edited the config file, you can reload it (which will create a new instance) field1_var = MyExampleConfig . get ( reload = True ) . section1 . field1 # you cannot programmatically change config parameters import MyExampleSettings # if the settings file is not in the default location, then set the path first MyExampleSettings . set_filepath ( r \"C:\\ProgramData\\MyApp\\settings.json\" ) # the next statement will create the settings name_var : str = MyExampleSettings . get () . basics . name # name_var == \"the name\" # the next statement just gets that same instance totals_var : int = MyExampleSettings . get () . basics . totals # totals_var == 2 # if you have edited the settings file, you can reload it (which will create a new instance) name_var = MyExampleSettings . get ( reload = True ) . basics . name # change settings parameters programmatically using update MyExampleSettings . update ({ \"basics\" : { \"name\" : \"new and shiny name\" , \"totals\" : 222 }}) print ( MyExampleSettings . get () . basics . totals ) # 222 print ( MyExampleSettings . get ( reload = True ) . basics . name ) # new and shiny name","title":"4. Using parameters"},{"location":"docs/4-Using_parameters/#use-parameters-in-your-code","text":"Parameter containers are meant to be instantiated just once and be available globally for the application. Therefore, implementation has been done as follows: The instance of a parameter container is accessed via a class method get() ; The parameter value is then obtained by chaining with the section name and the parameter name; The first invocation of get() will create the container instance, try to read values from file and store it for future access in a private module global (a dictionary with the class id as key); A parameter container should not be instantiated directly by client code (although it is possible to do so, e.g. for testing purposes); If needed, you can set the path for the parameter file before the first invocation of get() .","title":"Use parameters in your code"},{"location":"docs/4-Using_parameters/#changing-parameter-values","text":"Parameters are defined as fields of frozen dataclasses. Hence, changing parameter values by means of straightforward assignment will raise an error. Config parameters are meant to be read only. Changing values of such parameters has to be done by editing the config file and restarting your application or reloading the config container. Obviously, settings parameters can also be changed by editing the settings file and restarting the application or reloading the settings container. In addition to that, settings can be changed programmatically by calling a class method update(changes: dict[str, dict[str, Any]) , where the argument changes is a dictionary of dictionaries that specifies the sections (keys of the outer dict) and fields (keys of the inner dicts) that are changed. The method update will replace the stored settings in the private module global with an updated instance and the settings file will be updated as well. So the invocation of get() after update or application restart or reloading will return the changed parameter values.","title":"Changing parameter values"},{"location":"docs/4-Using_parameters/#example","text":"Configuration Settings import MyExampleConfig # if the config file is not in the default location, then set the path first MyExampleConfig . set_filepath ( r \"C:\\ProgramData\\MyApp\\config.toml\" ) # the next statement will create the config field1_var : str = MyExampleConfig . get () . section1 . field1 # field1_var == \"my own version of the first field\" # the next statement just gets that same instance field2_var : int = MyExampleConfig . get () . section1 . field2 # field2_var == 22 # if you have edited the config file, you can reload it (which will create a new instance) field1_var = MyExampleConfig . get ( reload = True ) . section1 . field1 # you cannot programmatically change config parameters import MyExampleSettings # if the settings file is not in the default location, then set the path first MyExampleSettings . set_filepath ( r \"C:\\ProgramData\\MyApp\\settings.json\" ) # the next statement will create the settings name_var : str = MyExampleSettings . get () . basics . name # name_var == \"the name\" # the next statement just gets that same instance totals_var : int = MyExampleSettings . get () . basics . totals # totals_var == 2 # if you have edited the settings file, you can reload it (which will create a new instance) name_var = MyExampleSettings . get ( reload = True ) . basics . name # change settings parameters programmatically using update MyExampleSettings . update ({ \"basics\" : { \"name\" : \"new and shiny name\" , \"totals\" : 222 }}) print ( MyExampleSettings . get () . basics . totals ) # 222 print ( MyExampleSettings . get ( reload = True ) . basics . name ) # new and shiny name","title":"Example"},{"location":"docs/5-Handling_deviations/","text":"Handling deviations in the config file When your config file does not adhere to the specified types When loading the config file, the values specified are coerced into the appropriate type where possible. If type coercion is not possible, then a pydantic.ValidationError is raised. Consider the case where you would use the following config file for the MyExampleConfig defined above: [section1] field1 = true field2 = \"22\" The bool specified for field1 will be coerced into a str value of \"true\" . The str specified for field2 will be coerced into an int value of 22 . When your config file does not contain all specified attributes If your Config has one of more sections with attributes that do not have a default value, then a config file must be loaded and these sections and attributes must be present in the loaded config file. If this is not the case, a TypeError is raised. Attributes that have default values can be omitted from the config file without problems. Note that in the dataclass definitions, attributes without default value have to come before attributes with default values. When your config file contains additional, unspecified attributes Entries in a config file that are not defined in the Config(Section) classes will simply be ignored silently. More advanced typing and validation with pydantic Non-standard types useful for configuration, such as network addresses, are offered, see pydantic types The value of numerous common types can be restricted using pydantic constrained types","title":"5. Handling deviations"},{"location":"docs/5-Handling_deviations/#handling-deviations-in-the-config-file","text":"","title":"Handling deviations in the config file"},{"location":"docs/5-Handling_deviations/#when-your-config-file-does-not-adhere-to-the-specified-types","text":"When loading the config file, the values specified are coerced into the appropriate type where possible. If type coercion is not possible, then a pydantic.ValidationError is raised. Consider the case where you would use the following config file for the MyExampleConfig defined above: [section1] field1 = true field2 = \"22\" The bool specified for field1 will be coerced into a str value of \"true\" . The str specified for field2 will be coerced into an int value of 22 .","title":"When your config file does not adhere to the specified types"},{"location":"docs/5-Handling_deviations/#when-your-config-file-does-not-contain-all-specified-attributes","text":"If your Config has one of more sections with attributes that do not have a default value, then a config file must be loaded and these sections and attributes must be present in the loaded config file. If this is not the case, a TypeError is raised. Attributes that have default values can be omitted from the config file without problems. Note that in the dataclass definitions, attributes without default value have to come before attributes with default values.","title":"When your config file does not contain all specified attributes"},{"location":"docs/5-Handling_deviations/#when-your-config-file-contains-additional-unspecified-attributes","text":"Entries in a config file that are not defined in the Config(Section) classes will simply be ignored silently.","title":"When your config file contains additional, unspecified attributes"},{"location":"docs/5-Handling_deviations/#more-advanced-typing-and-validation-with-pydantic","text":"Non-standard types useful for configuration, such as network addresses, are offered, see pydantic types The value of numerous common types can be restricted using pydantic constrained types","title":"More advanced typing and validation with pydantic"},{"location":"docs/Quick_start/","text":"Quick start Install the package pip install -U application_settings Define dataclasses for configuration / settings parameters Config is for read-only parameters read from file, Settings are read-write parameters stored to file for persistancy over sessions. During definition, they differ only in terms of the base classes that are used. Example: Configuration Settings from application_settings import ( ConfigBase , ConfigSectionBase , ) from pydantic.dataclasses import dataclass @dataclass ( frozen = True ) class MyExampleConfigSection ( ConfigSectionBase ): \"\"\"Config section for an example\"\"\" field1 : str = \"field1\" field2 : int = 2 @dataclass ( frozen = True ) class MyExampleConfig ( ConfigBase ): \"\"\"Config for an example\"\"\" section1 : MyExampleConfigSection = MyExampleConfigSection () from application_settings import ( SettingsBase , SettingsSectionBase , ) from pydantic.dataclasses import dataclass @dataclass ( frozen = True ) class BasicSettingsSection ( SettingsSectionBase ): \"\"\"Settings section for the basics\"\"\" name : str = \"the name\" totals : int = 2 @dataclass ( frozen = True ) class MyExampleSettings ( SettingsBase ): \"\"\"Settings for an example\"\"\" basics : BasicSettingsSection = BasicSettingsSection () Write (or generate) the file By default, the following files are expected for the dataclasses defined above: ~/.my_example/config.toml ~/.my_example/settings.json # The nice thing about toml is that you can add comments for explanation # A config is read-only, so they will not be overwritten by your application # (unlike for settings) [section1] field1 = \"my own version of the first field\" field2 = 22 { \"basics\" : { \"name\" : \"the stored name\" , \"totals\" : 3 } } Use parameters in your code Configuration Settings # the first invocation of get() will create the singleton instance of MyExampleConfig a_variable = MyExampleConfig . get () . section1 . field1 # a_variable == \"my own version of field1\" another_variable = MyExampleConfig . get () . section1 . field2 # another_variable == 22 # The only way to modify a config parameter is by editing the config file # or by changing the default value in the definition # Suppose that we edited the config file, changed field1 to \"new field 1\" and removed field2 # you can reload a config new_variable = MyExampleConfig . get ( reload = True ) . section1 . field1 # new_variable == \"new field 1\" another_new_variable = MyExampleConfig . get () . section1 . field2 # another_new_variable == 2 # the first invocation of get() will create the singleton instance of MyExampleSettings a_variable : str = MyExampleSettings . get () . basics . name # a_variable == \"the stored name\" another_variable : int = MyExampleConfig . get () . basics . totals # another_variable == 3 # You can update the settings: MyExampleSettings . update ({ \"basics\" : { \"totals\" : 33 }}) # The updated values will be written to the settings file automatically and the # singleton is replaced by a new instance of MyExampleSettings with the updated values # you can also edit the settings file and reload: refreshed_name = MyExampleSettings . get ( reload = True ) . basics . name These are the basics; a more detailed description is found in the next section (Usage) or you can take a look at the API (Reference).","title":"Quick start"},{"location":"docs/Quick_start/#quick-start","text":"","title":"Quick start"},{"location":"docs/Quick_start/#install-the-package","text":"pip install -U application_settings","title":"Install the package"},{"location":"docs/Quick_start/#define-dataclasses-for-configuration-settings-parameters","text":"Config is for read-only parameters read from file, Settings are read-write parameters stored to file for persistancy over sessions. During definition, they differ only in terms of the base classes that are used. Example: Configuration Settings from application_settings import ( ConfigBase , ConfigSectionBase , ) from pydantic.dataclasses import dataclass @dataclass ( frozen = True ) class MyExampleConfigSection ( ConfigSectionBase ): \"\"\"Config section for an example\"\"\" field1 : str = \"field1\" field2 : int = 2 @dataclass ( frozen = True ) class MyExampleConfig ( ConfigBase ): \"\"\"Config for an example\"\"\" section1 : MyExampleConfigSection = MyExampleConfigSection () from application_settings import ( SettingsBase , SettingsSectionBase , ) from pydantic.dataclasses import dataclass @dataclass ( frozen = True ) class BasicSettingsSection ( SettingsSectionBase ): \"\"\"Settings section for the basics\"\"\" name : str = \"the name\" totals : int = 2 @dataclass ( frozen = True ) class MyExampleSettings ( SettingsBase ): \"\"\"Settings for an example\"\"\" basics : BasicSettingsSection = BasicSettingsSection ()","title":"Define dataclasses for configuration / settings parameters"},{"location":"docs/Quick_start/#write-or-generate-the-file","text":"By default, the following files are expected for the dataclasses defined above: ~/.my_example/config.toml ~/.my_example/settings.json # The nice thing about toml is that you can add comments for explanation # A config is read-only, so they will not be overwritten by your application # (unlike for settings) [section1] field1 = \"my own version of the first field\" field2 = 22 { \"basics\" : { \"name\" : \"the stored name\" , \"totals\" : 3 } }","title":"Write (or generate) the file"},{"location":"docs/Quick_start/#use-parameters-in-your-code","text":"Configuration Settings # the first invocation of get() will create the singleton instance of MyExampleConfig a_variable = MyExampleConfig . get () . section1 . field1 # a_variable == \"my own version of field1\" another_variable = MyExampleConfig . get () . section1 . field2 # another_variable == 22 # The only way to modify a config parameter is by editing the config file # or by changing the default value in the definition # Suppose that we edited the config file, changed field1 to \"new field 1\" and removed field2 # you can reload a config new_variable = MyExampleConfig . get ( reload = True ) . section1 . field1 # new_variable == \"new field 1\" another_new_variable = MyExampleConfig . get () . section1 . field2 # another_new_variable == 2 # the first invocation of get() will create the singleton instance of MyExampleSettings a_variable : str = MyExampleSettings . get () . basics . name # a_variable == \"the stored name\" another_variable : int = MyExampleConfig . get () . basics . totals # another_variable == 3 # You can update the settings: MyExampleSettings . update ({ \"basics\" : { \"totals\" : 33 }}) # The updated values will be written to the settings file automatically and the # singleton is replaced by a new instance of MyExampleSettings with the updated values # you can also edit the settings file and reload: refreshed_name = MyExampleSettings . get ( reload = True ) . basics . name These are the basics; a more detailed description is found in the next section (Usage) or you can take a look at the API (Reference).","title":"Use parameters in your code"},{"location":"reference/application_settings/","text":"Module application_settings Module for loading and retrieving configuration. ??? example \"View Source\" \"\"\"Module for loading and retrieving configuration.\"\"\" from importlib.metadata import version from .configuring_base import ConfigBase, ConfigSectionBase, ConfigSectionT, ConfigT from .settings_base import ( SettingsBase, SettingsSectionBase, SettingsSectionT, SettingsT, ) from .type_notation_helper import PathOpt, PathOrStr __version__ = version(\"application_settings\") __all__ = [ \"ConfigSectionT\", \"ConfigT\", \"ConfigSectionBase\", \"ConfigBase\", \"PathOpt\", \"PathOrStr\", \"SettingsSectionT\", \"SettingsT\", \"SettingsSectionBase\", \"SettingsBase\", ] Sub-modules application_settings.configuring_base application_settings.container_base application_settings.settings_base application_settings.type_notation_helper Variables ConfigSectionT ConfigT PathOpt PathOrStr SettingsSectionT SettingsT Classes ConfigBase class ConfigBase ( ) Base class for main Config class ??? example \"View Source\" @dataclass(frozen=True) class ConfigBase(ContainerBase): \"\"\"Base class for main Config class\"\"\" @classmethod def kind_string(cls: type[ConfigT]) -> ContainerTypeStr: \"Return 'Config'\" return \"Config\" @classmethod def default_file_format(cls: type[ConfigT]) -> FileFormat: \"Return the default file format\" return FileFormat.TOML def update(self: ConfigT, changes: dict[str, dict[str, Any]]) -> ConfigT: \"Update and save the settings with data specified in changes; not meant for config\" raise TypeError( \"Configs should not be updated runtime; consider converting to settings.\" ) Ancestors (in MRO) application_settings.container_base.ContainerBase abc.ABC Static methods default_file_format def default_file_format ( ) -> application_settings . container_base . FileFormat Return the default file format ??? example \"View Source\" @classmethod def default_file_format(cls: type[ConfigT]) -> FileFormat: \"Return the default file format\" return FileFormat.TOML default_filename def default_filename ( ) -> str Return the kind_string, lowercase, with the extension that fits the file_format. ??? example \"View Source\" @classmethod def default_filename(cls: type[_ContainerT]) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\" default_filepath def default_filepath ( ) -> pathlib . Path | None Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml ??? example \"View Source\" @classmethod def default_filepath(cls: type[_ContainerT]) -> PathOpt: \"\"\"Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml\"\"\" return Path.home() / cls.default_foldername() / cls.default_filename() default_foldername def default_foldername ( ) -> str Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words. ??? example \"View Source\" @classmethod def default_foldername(cls: type[_ContainerT]) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" kind_str = cls.kind_string() return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() ) filepath def filepath ( ) -> pathlib . Path | None Return the path for the file that holds the config / settings. ??? example \"View Source\" @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath()) get def get ( reload : bool = False ) -> ~ _ContainerT Access method for the singleton. ??? example \"View Source\" @classmethod def get(cls: type[_ContainerT], reload: bool = False) -> _ContainerT: \"\"\"Access method for the singleton.\"\"\" if (_the_container_or_none := cls._get()) is None or reload: # no config has been made yet or it needs to be reloaded, # so let's instantiate one and keep it in the global store _the_config = cls._create_instance() _the_config._set() else: _the_config = _the_container_or_none return _the_config kind_string def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Config' ??? example \"View Source\" @classmethod def kind_string(cls: type[ConfigT]) -> ContainerTypeStr: \"Return 'Config'\" return \"Config\" set_filepath def set_filepath ( file_path : pathlib . Path | str = '' ) -> None Set the path for the file (a singleton). ??? example \"View Source\" @classmethod def set_filepath(cls: type[_ContainerT], file_path: PathOrStr = \"\") -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) Methods update def update ( self : ~ ConfigT , changes : dict [ str , dict [ str , typing . Any ]] ) -> ~ ConfigT Update and save the settings with data specified in changes; not meant for config ??? example \"View Source\" def update(self: ConfigT, changes: dict[str, dict[str, Any]]) -> ConfigT: \"Update and save the settings with data specified in changes; not meant for config\" raise TypeError( \"Configs should not be updated runtime; consider converting to settings.\" ) ConfigSectionBase class ConfigSectionBase ( ) Base class for all ConfigSection classes (so that we can bound a TypeVar) ??? example \"View Source\" @dataclass(frozen=True) class ConfigSectionBase(ContainerSectionBase): \"\"\"Base class for all ConfigSection classes (so that we can bound a TypeVar)\"\"\" Ancestors (in MRO) application_settings.container_base.ContainerSectionBase SettingsBase class SettingsBase ( ) Base class for main Settings class ??? example \"View Source\" @dataclass(frozen=True) class SettingsBase(ContainerBase): \"\"\"Base class for main Settings class\"\"\" @classmethod def kind_string(cls: type[SettingsT]) -> ContainerTypeStr: \"Return 'Settings'\" return \"Settings\" @classmethod def default_file_format(cls: type[SettingsT]) -> FileFormat: \"Return the default file format\" return FileFormat.JSON Ancestors (in MRO) application_settings.container_base.ContainerBase abc.ABC Static methods default_file_format def default_file_format ( ) -> application_settings . container_base . FileFormat Return the default file format ??? example \"View Source\" @classmethod def default_file_format(cls: type[SettingsT]) -> FileFormat: \"Return the default file format\" return FileFormat.JSON default_filename def default_filename ( ) -> str Return the kind_string, lowercase, with the extension that fits the file_format. ??? example \"View Source\" @classmethod def default_filename(cls: type[_ContainerT]) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\" default_filepath def default_filepath ( ) -> pathlib . Path | None Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml ??? example \"View Source\" @classmethod def default_filepath(cls: type[_ContainerT]) -> PathOpt: \"\"\"Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml\"\"\" return Path.home() / cls.default_foldername() / cls.default_filename() default_foldername def default_foldername ( ) -> str Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words. ??? example \"View Source\" @classmethod def default_foldername(cls: type[_ContainerT]) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" kind_str = cls.kind_string() return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() ) filepath def filepath ( ) -> pathlib . Path | None Return the path for the file that holds the config / settings. ??? example \"View Source\" @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath()) get def get ( reload : bool = False ) -> ~ _ContainerT Access method for the singleton. ??? example \"View Source\" @classmethod def get(cls: type[_ContainerT], reload: bool = False) -> _ContainerT: \"\"\"Access method for the singleton.\"\"\" if (_the_container_or_none := cls._get()) is None or reload: # no config has been made yet or it needs to be reloaded, # so let's instantiate one and keep it in the global store _the_config = cls._create_instance() _the_config._set() else: _the_config = _the_container_or_none return _the_config kind_string def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Settings' ??? example \"View Source\" @classmethod def kind_string(cls: type[SettingsT]) -> ContainerTypeStr: \"Return 'Settings'\" return \"Settings\" set_filepath def set_filepath ( file_path : pathlib . Path | str = '' ) -> None Set the path for the file (a singleton). ??? example \"View Source\" @classmethod def set_filepath(cls: type[_ContainerT], file_path: PathOrStr = \"\") -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) update def update ( changes : dict [ str , dict [ str , typing . Any ]] ) -> ~ _ContainerT Update and save the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update( cls: type[_ContainerT], changes: dict[str, dict[str, Any]] ) -> _ContainerT: \"Update and save the settings with data specified in changes; not meant for config\" return cls.get()._update(changes) # pylint: disable=protected-access SettingsSectionBase class SettingsSectionBase ( ) Base class for all SettingsSection classes (so that we can bound a TypeVar) ??? example \"View Source\" @dataclass(frozen=True) class SettingsSectionBase(ContainerSectionBase): \"\"\"Base class for all SettingsSection classes (so that we can bound a TypeVar)\"\"\" Ancestors (in MRO) application_settings.container_base.ContainerSectionBase","title":"Index"},{"location":"reference/application_settings/#module-application_settings","text":"Module for loading and retrieving configuration. ??? example \"View Source\" \"\"\"Module for loading and retrieving configuration.\"\"\" from importlib.metadata import version from .configuring_base import ConfigBase, ConfigSectionBase, ConfigSectionT, ConfigT from .settings_base import ( SettingsBase, SettingsSectionBase, SettingsSectionT, SettingsT, ) from .type_notation_helper import PathOpt, PathOrStr __version__ = version(\"application_settings\") __all__ = [ \"ConfigSectionT\", \"ConfigT\", \"ConfigSectionBase\", \"ConfigBase\", \"PathOpt\", \"PathOrStr\", \"SettingsSectionT\", \"SettingsT\", \"SettingsSectionBase\", \"SettingsBase\", ]","title":"Module application_settings"},{"location":"reference/application_settings/#sub-modules","text":"application_settings.configuring_base application_settings.container_base application_settings.settings_base application_settings.type_notation_helper","title":"Sub-modules"},{"location":"reference/application_settings/#variables","text":"ConfigSectionT ConfigT PathOpt PathOrStr SettingsSectionT SettingsT","title":"Variables"},{"location":"reference/application_settings/#classes","text":"","title":"Classes"},{"location":"reference/application_settings/#configbase","text":"class ConfigBase ( ) Base class for main Config class ??? example \"View Source\" @dataclass(frozen=True) class ConfigBase(ContainerBase): \"\"\"Base class for main Config class\"\"\" @classmethod def kind_string(cls: type[ConfigT]) -> ContainerTypeStr: \"Return 'Config'\" return \"Config\" @classmethod def default_file_format(cls: type[ConfigT]) -> FileFormat: \"Return the default file format\" return FileFormat.TOML def update(self: ConfigT, changes: dict[str, dict[str, Any]]) -> ConfigT: \"Update and save the settings with data specified in changes; not meant for config\" raise TypeError( \"Configs should not be updated runtime; consider converting to settings.\" )","title":"ConfigBase"},{"location":"reference/application_settings/#ancestors-in-mro","text":"application_settings.container_base.ContainerBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/application_settings/#static-methods","text":"","title":"Static methods"},{"location":"reference/application_settings/#default_file_format","text":"def default_file_format ( ) -> application_settings . container_base . FileFormat Return the default file format ??? example \"View Source\" @classmethod def default_file_format(cls: type[ConfigT]) -> FileFormat: \"Return the default file format\" return FileFormat.TOML","title":"default_file_format"},{"location":"reference/application_settings/#default_filename","text":"def default_filename ( ) -> str Return the kind_string, lowercase, with the extension that fits the file_format. ??? example \"View Source\" @classmethod def default_filename(cls: type[_ContainerT]) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\"","title":"default_filename"},{"location":"reference/application_settings/#default_filepath","text":"def default_filepath ( ) -> pathlib . Path | None Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml ??? example \"View Source\" @classmethod def default_filepath(cls: type[_ContainerT]) -> PathOpt: \"\"\"Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml\"\"\" return Path.home() / cls.default_foldername() / cls.default_filename()","title":"default_filepath"},{"location":"reference/application_settings/#default_foldername","text":"def default_foldername ( ) -> str Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words. ??? example \"View Source\" @classmethod def default_foldername(cls: type[_ContainerT]) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" kind_str = cls.kind_string() return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() )","title":"default_foldername"},{"location":"reference/application_settings/#filepath","text":"def filepath ( ) -> pathlib . Path | None Return the path for the file that holds the config / settings. ??? example \"View Source\" @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath())","title":"filepath"},{"location":"reference/application_settings/#get","text":"def get ( reload : bool = False ) -> ~ _ContainerT Access method for the singleton. ??? example \"View Source\" @classmethod def get(cls: type[_ContainerT], reload: bool = False) -> _ContainerT: \"\"\"Access method for the singleton.\"\"\" if (_the_container_or_none := cls._get()) is None or reload: # no config has been made yet or it needs to be reloaded, # so let's instantiate one and keep it in the global store _the_config = cls._create_instance() _the_config._set() else: _the_config = _the_container_or_none return _the_config","title":"get"},{"location":"reference/application_settings/#kind_string","text":"def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Config' ??? example \"View Source\" @classmethod def kind_string(cls: type[ConfigT]) -> ContainerTypeStr: \"Return 'Config'\" return \"Config\"","title":"kind_string"},{"location":"reference/application_settings/#set_filepath","text":"def set_filepath ( file_path : pathlib . Path | str = '' ) -> None Set the path for the file (a singleton). ??? example \"View Source\" @classmethod def set_filepath(cls: type[_ContainerT], file_path: PathOrStr = \"\") -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None)","title":"set_filepath"},{"location":"reference/application_settings/#methods","text":"","title":"Methods"},{"location":"reference/application_settings/#update","text":"def update ( self : ~ ConfigT , changes : dict [ str , dict [ str , typing . Any ]] ) -> ~ ConfigT Update and save the settings with data specified in changes; not meant for config ??? example \"View Source\" def update(self: ConfigT, changes: dict[str, dict[str, Any]]) -> ConfigT: \"Update and save the settings with data specified in changes; not meant for config\" raise TypeError( \"Configs should not be updated runtime; consider converting to settings.\" )","title":"update"},{"location":"reference/application_settings/#configsectionbase","text":"class ConfigSectionBase ( ) Base class for all ConfigSection classes (so that we can bound a TypeVar) ??? example \"View Source\" @dataclass(frozen=True) class ConfigSectionBase(ContainerSectionBase): \"\"\"Base class for all ConfigSection classes (so that we can bound a TypeVar)\"\"\"","title":"ConfigSectionBase"},{"location":"reference/application_settings/#ancestors-in-mro_1","text":"application_settings.container_base.ContainerSectionBase","title":"Ancestors (in MRO)"},{"location":"reference/application_settings/#settingsbase","text":"class SettingsBase ( ) Base class for main Settings class ??? example \"View Source\" @dataclass(frozen=True) class SettingsBase(ContainerBase): \"\"\"Base class for main Settings class\"\"\" @classmethod def kind_string(cls: type[SettingsT]) -> ContainerTypeStr: \"Return 'Settings'\" return \"Settings\" @classmethod def default_file_format(cls: type[SettingsT]) -> FileFormat: \"Return the default file format\" return FileFormat.JSON","title":"SettingsBase"},{"location":"reference/application_settings/#ancestors-in-mro_2","text":"application_settings.container_base.ContainerBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/application_settings/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/application_settings/#default_file_format_1","text":"def default_file_format ( ) -> application_settings . container_base . FileFormat Return the default file format ??? example \"View Source\" @classmethod def default_file_format(cls: type[SettingsT]) -> FileFormat: \"Return the default file format\" return FileFormat.JSON","title":"default_file_format"},{"location":"reference/application_settings/#default_filename_1","text":"def default_filename ( ) -> str Return the kind_string, lowercase, with the extension that fits the file_format. ??? example \"View Source\" @classmethod def default_filename(cls: type[_ContainerT]) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\"","title":"default_filename"},{"location":"reference/application_settings/#default_filepath_1","text":"def default_filepath ( ) -> pathlib . Path | None Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml ??? example \"View Source\" @classmethod def default_filepath(cls: type[_ContainerT]) -> PathOpt: \"\"\"Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml\"\"\" return Path.home() / cls.default_foldername() / cls.default_filename()","title":"default_filepath"},{"location":"reference/application_settings/#default_foldername_1","text":"def default_foldername ( ) -> str Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words. ??? example \"View Source\" @classmethod def default_foldername(cls: type[_ContainerT]) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" kind_str = cls.kind_string() return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() )","title":"default_foldername"},{"location":"reference/application_settings/#filepath_1","text":"def filepath ( ) -> pathlib . Path | None Return the path for the file that holds the config / settings. ??? example \"View Source\" @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath())","title":"filepath"},{"location":"reference/application_settings/#get_1","text":"def get ( reload : bool = False ) -> ~ _ContainerT Access method for the singleton. ??? example \"View Source\" @classmethod def get(cls: type[_ContainerT], reload: bool = False) -> _ContainerT: \"\"\"Access method for the singleton.\"\"\" if (_the_container_or_none := cls._get()) is None or reload: # no config has been made yet or it needs to be reloaded, # so let's instantiate one and keep it in the global store _the_config = cls._create_instance() _the_config._set() else: _the_config = _the_container_or_none return _the_config","title":"get"},{"location":"reference/application_settings/#kind_string_1","text":"def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Settings' ??? example \"View Source\" @classmethod def kind_string(cls: type[SettingsT]) -> ContainerTypeStr: \"Return 'Settings'\" return \"Settings\"","title":"kind_string"},{"location":"reference/application_settings/#set_filepath_1","text":"def set_filepath ( file_path : pathlib . Path | str = '' ) -> None Set the path for the file (a singleton). ??? example \"View Source\" @classmethod def set_filepath(cls: type[_ContainerT], file_path: PathOrStr = \"\") -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None)","title":"set_filepath"},{"location":"reference/application_settings/#update_1","text":"def update ( changes : dict [ str , dict [ str , typing . Any ]] ) -> ~ _ContainerT Update and save the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update( cls: type[_ContainerT], changes: dict[str, dict[str, Any]] ) -> _ContainerT: \"Update and save the settings with data specified in changes; not meant for config\" return cls.get()._update(changes) # pylint: disable=protected-access","title":"update"},{"location":"reference/application_settings/#settingssectionbase","text":"class SettingsSectionBase ( ) Base class for all SettingsSection classes (so that we can bound a TypeVar) ??? example \"View Source\" @dataclass(frozen=True) class SettingsSectionBase(ContainerSectionBase): \"\"\"Base class for all SettingsSection classes (so that we can bound a TypeVar)\"\"\"","title":"SettingsSectionBase"},{"location":"reference/application_settings/#ancestors-in-mro_3","text":"application_settings.container_base.ContainerSectionBase","title":"Ancestors (in MRO)"},{"location":"reference/application_settings/configuring_base/","text":"Module application_settings.configuring_base Module for handling configuration. ??? example \"View Source\" \"\"\"Module for handling configuration.\"\"\" from typing import Any, TypeVar from pydantic.dataclasses import dataclass from .container_base import ( ContainerBase, ContainerSectionBase, ContainerTypeStr, FileFormat, ) ConfigT = TypeVar(\"ConfigT\", bound=\"ConfigBase\") ConfigSectionT = TypeVar(\"ConfigSectionT\", bound=\"ConfigSectionBase\") @dataclass(frozen=True) class ConfigSectionBase(ContainerSectionBase): \"\"\"Base class for all ConfigSection classes (so that we can bound a TypeVar)\"\"\" @dataclass(frozen=True) class ConfigBase(ContainerBase): \"\"\"Base class for main Config class\"\"\" @classmethod def kind_string(cls: type[ConfigT]) -> ContainerTypeStr: \"Return 'Config'\" return \"Config\" @classmethod def default_file_format(cls: type[ConfigT]) -> FileFormat: \"Return the default file format\" return FileFormat.TOML def update(self: ConfigT, changes: dict[str, dict[str, Any]]) -> ConfigT: \"Update and save the settings with data specified in changes; not meant for config\" raise TypeError( \"Configs should not be updated runtime; consider converting to settings.\" ) Variables ConfigSectionT ConfigT Classes ConfigBase class ConfigBase ( ) Base class for main Config class ??? example \"View Source\" @dataclass(frozen=True) class ConfigBase(ContainerBase): \"\"\"Base class for main Config class\"\"\" @classmethod def kind_string(cls: type[ConfigT]) -> ContainerTypeStr: \"Return 'Config'\" return \"Config\" @classmethod def default_file_format(cls: type[ConfigT]) -> FileFormat: \"Return the default file format\" return FileFormat.TOML def update(self: ConfigT, changes: dict[str, dict[str, Any]]) -> ConfigT: \"Update and save the settings with data specified in changes; not meant for config\" raise TypeError( \"Configs should not be updated runtime; consider converting to settings.\" ) Ancestors (in MRO) application_settings.container_base.ContainerBase abc.ABC Static methods default_file_format def default_file_format ( ) -> application_settings . container_base . FileFormat Return the default file format ??? example \"View Source\" @classmethod def default_file_format(cls: type[ConfigT]) -> FileFormat: \"Return the default file format\" return FileFormat.TOML default_filename def default_filename ( ) -> str Return the kind_string, lowercase, with the extension that fits the file_format. ??? example \"View Source\" @classmethod def default_filename(cls: type[_ContainerT]) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\" default_filepath def default_filepath ( ) -> pathlib . Path | None Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml ??? example \"View Source\" @classmethod def default_filepath(cls: type[_ContainerT]) -> PathOpt: \"\"\"Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml\"\"\" return Path.home() / cls.default_foldername() / cls.default_filename() default_foldername def default_foldername ( ) -> str Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words. ??? example \"View Source\" @classmethod def default_foldername(cls: type[_ContainerT]) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" kind_str = cls.kind_string() return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() ) filepath def filepath ( ) -> pathlib . Path | None Return the path for the file that holds the config / settings. ??? example \"View Source\" @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath()) get def get ( reload : bool = False ) -> ~ _ContainerT Access method for the singleton. ??? example \"View Source\" @classmethod def get(cls: type[_ContainerT], reload: bool = False) -> _ContainerT: \"\"\"Access method for the singleton.\"\"\" if (_the_container_or_none := cls._get()) is None or reload: # no config has been made yet or it needs to be reloaded, # so let's instantiate one and keep it in the global store _the_config = cls._create_instance() _the_config._set() else: _the_config = _the_container_or_none return _the_config kind_string def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Config' ??? example \"View Source\" @classmethod def kind_string(cls: type[ConfigT]) -> ContainerTypeStr: \"Return 'Config'\" return \"Config\" set_filepath def set_filepath ( file_path : pathlib . Path | str = '' ) -> None Set the path for the file (a singleton). ??? example \"View Source\" @classmethod def set_filepath(cls: type[_ContainerT], file_path: PathOrStr = \"\") -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) Methods update def update ( self : ~ ConfigT , changes : dict [ str , dict [ str , typing . Any ]] ) -> ~ ConfigT Update and save the settings with data specified in changes; not meant for config ??? example \"View Source\" def update(self: ConfigT, changes: dict[str, dict[str, Any]]) -> ConfigT: \"Update and save the settings with data specified in changes; not meant for config\" raise TypeError( \"Configs should not be updated runtime; consider converting to settings.\" ) ConfigSectionBase class ConfigSectionBase ( ) Base class for all ConfigSection classes (so that we can bound a TypeVar) ??? example \"View Source\" @dataclass(frozen=True) class ConfigSectionBase(ContainerSectionBase): \"\"\"Base class for all ConfigSection classes (so that we can bound a TypeVar)\"\"\" Ancestors (in MRO) application_settings.container_base.ContainerSectionBase","title":"Configuring Base"},{"location":"reference/application_settings/configuring_base/#module-application_settingsconfiguring_base","text":"Module for handling configuration. ??? example \"View Source\" \"\"\"Module for handling configuration.\"\"\" from typing import Any, TypeVar from pydantic.dataclasses import dataclass from .container_base import ( ContainerBase, ContainerSectionBase, ContainerTypeStr, FileFormat, ) ConfigT = TypeVar(\"ConfigT\", bound=\"ConfigBase\") ConfigSectionT = TypeVar(\"ConfigSectionT\", bound=\"ConfigSectionBase\") @dataclass(frozen=True) class ConfigSectionBase(ContainerSectionBase): \"\"\"Base class for all ConfigSection classes (so that we can bound a TypeVar)\"\"\" @dataclass(frozen=True) class ConfigBase(ContainerBase): \"\"\"Base class for main Config class\"\"\" @classmethod def kind_string(cls: type[ConfigT]) -> ContainerTypeStr: \"Return 'Config'\" return \"Config\" @classmethod def default_file_format(cls: type[ConfigT]) -> FileFormat: \"Return the default file format\" return FileFormat.TOML def update(self: ConfigT, changes: dict[str, dict[str, Any]]) -> ConfigT: \"Update and save the settings with data specified in changes; not meant for config\" raise TypeError( \"Configs should not be updated runtime; consider converting to settings.\" )","title":"Module application_settings.configuring_base"},{"location":"reference/application_settings/configuring_base/#variables","text":"ConfigSectionT ConfigT","title":"Variables"},{"location":"reference/application_settings/configuring_base/#classes","text":"","title":"Classes"},{"location":"reference/application_settings/configuring_base/#configbase","text":"class ConfigBase ( ) Base class for main Config class ??? example \"View Source\" @dataclass(frozen=True) class ConfigBase(ContainerBase): \"\"\"Base class for main Config class\"\"\" @classmethod def kind_string(cls: type[ConfigT]) -> ContainerTypeStr: \"Return 'Config'\" return \"Config\" @classmethod def default_file_format(cls: type[ConfigT]) -> FileFormat: \"Return the default file format\" return FileFormat.TOML def update(self: ConfigT, changes: dict[str, dict[str, Any]]) -> ConfigT: \"Update and save the settings with data specified in changes; not meant for config\" raise TypeError( \"Configs should not be updated runtime; consider converting to settings.\" )","title":"ConfigBase"},{"location":"reference/application_settings/configuring_base/#ancestors-in-mro","text":"application_settings.container_base.ContainerBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/application_settings/configuring_base/#static-methods","text":"","title":"Static methods"},{"location":"reference/application_settings/configuring_base/#default_file_format","text":"def default_file_format ( ) -> application_settings . container_base . FileFormat Return the default file format ??? example \"View Source\" @classmethod def default_file_format(cls: type[ConfigT]) -> FileFormat: \"Return the default file format\" return FileFormat.TOML","title":"default_file_format"},{"location":"reference/application_settings/configuring_base/#default_filename","text":"def default_filename ( ) -> str Return the kind_string, lowercase, with the extension that fits the file_format. ??? example \"View Source\" @classmethod def default_filename(cls: type[_ContainerT]) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\"","title":"default_filename"},{"location":"reference/application_settings/configuring_base/#default_filepath","text":"def default_filepath ( ) -> pathlib . Path | None Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml ??? example \"View Source\" @classmethod def default_filepath(cls: type[_ContainerT]) -> PathOpt: \"\"\"Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml\"\"\" return Path.home() / cls.default_foldername() / cls.default_filename()","title":"default_filepath"},{"location":"reference/application_settings/configuring_base/#default_foldername","text":"def default_foldername ( ) -> str Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words. ??? example \"View Source\" @classmethod def default_foldername(cls: type[_ContainerT]) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" kind_str = cls.kind_string() return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() )","title":"default_foldername"},{"location":"reference/application_settings/configuring_base/#filepath","text":"def filepath ( ) -> pathlib . Path | None Return the path for the file that holds the config / settings. ??? example \"View Source\" @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath())","title":"filepath"},{"location":"reference/application_settings/configuring_base/#get","text":"def get ( reload : bool = False ) -> ~ _ContainerT Access method for the singleton. ??? example \"View Source\" @classmethod def get(cls: type[_ContainerT], reload: bool = False) -> _ContainerT: \"\"\"Access method for the singleton.\"\"\" if (_the_container_or_none := cls._get()) is None or reload: # no config has been made yet or it needs to be reloaded, # so let's instantiate one and keep it in the global store _the_config = cls._create_instance() _the_config._set() else: _the_config = _the_container_or_none return _the_config","title":"get"},{"location":"reference/application_settings/configuring_base/#kind_string","text":"def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Config' ??? example \"View Source\" @classmethod def kind_string(cls: type[ConfigT]) -> ContainerTypeStr: \"Return 'Config'\" return \"Config\"","title":"kind_string"},{"location":"reference/application_settings/configuring_base/#set_filepath","text":"def set_filepath ( file_path : pathlib . Path | str = '' ) -> None Set the path for the file (a singleton). ??? example \"View Source\" @classmethod def set_filepath(cls: type[_ContainerT], file_path: PathOrStr = \"\") -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None)","title":"set_filepath"},{"location":"reference/application_settings/configuring_base/#methods","text":"","title":"Methods"},{"location":"reference/application_settings/configuring_base/#update","text":"def update ( self : ~ ConfigT , changes : dict [ str , dict [ str , typing . Any ]] ) -> ~ ConfigT Update and save the settings with data specified in changes; not meant for config ??? example \"View Source\" def update(self: ConfigT, changes: dict[str, dict[str, Any]]) -> ConfigT: \"Update and save the settings with data specified in changes; not meant for config\" raise TypeError( \"Configs should not be updated runtime; consider converting to settings.\" )","title":"update"},{"location":"reference/application_settings/configuring_base/#configsectionbase","text":"class ConfigSectionBase ( ) Base class for all ConfigSection classes (so that we can bound a TypeVar) ??? example \"View Source\" @dataclass(frozen=True) class ConfigSectionBase(ContainerSectionBase): \"\"\"Base class for all ConfigSection classes (so that we can bound a TypeVar)\"\"\"","title":"ConfigSectionBase"},{"location":"reference/application_settings/configuring_base/#ancestors-in-mro_1","text":"application_settings.container_base.ContainerSectionBase","title":"Ancestors (in MRO)"},{"location":"reference/application_settings/container_base/","text":"Module application_settings.container_base Base classes for containers and sections for configuration and settings. ??? example \"View Source\" # pylint: disable=consider-alternative-union-syntax \"\"\"Base classes for containers and sections for configuration and settings.\"\"\" import json import sys from abc import ABC, abstractmethod from dataclasses import asdict, fields, replace from enum import Enum, unique from pathlib import Path from re import sub from typing import Any, Literal, Optional, TypeVar import tomli_w from pathvalidate import is_valid_filepath from pydantic.dataclasses import dataclass from .type_notation_helper import PathOpt, PathOrStr if sys.version_info >= (3, 11): import tomllib else: import tomli as tomllib _ContainerT = TypeVar(\"_ContainerT\", bound=\"ContainerBase\") _ContainerSectionT = TypeVar(\"_ContainerSectionT\", bound=\"ContainerSectionBase\") _ALL_CONTAINERS: dict[int, Any] = {} _ALL_PATHS: dict[int, PathOpt] = {} @unique class FileFormat(Enum): \"File formats that are supported\" TOML = \"toml\" JSON = \"json\" ContainerTypeStr = Literal[\"Config\", \"Settings\"] @dataclass(frozen=True) class ContainerSectionBase: \"\"\"Base class for all ContainerSection classes (so that we can bound a TypeVar)\"\"\" @dataclass(frozen=True) class ContainerBase(ABC): \"\"\"Base class for Config and Settings classes\"\"\" @classmethod @abstractmethod def kind_string(cls: type[_ContainerT]) -> ContainerTypeStr: \"Return either 'Config' or 'Settings'\" @classmethod @abstractmethod def default_file_format(cls: type[_ContainerT]) -> FileFormat: \"Return the default file format\" @classmethod def default_foldername(cls: type[_ContainerT]) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" kind_str = cls.kind_string() return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() ) @classmethod def default_filename(cls: type[_ContainerT]) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\" @classmethod def default_filepath(cls: type[_ContainerT]) -> PathOpt: \"\"\"Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml\"\"\" return Path.home() / cls.default_foldername() / cls.default_filename() @classmethod def set_filepath(cls: type[_ContainerT], file_path: PathOrStr = \"\") -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath()) @classmethod def _get(cls: type[_ContainerT]) -> Optional[_ContainerT]: \"\"\"Private getter for the singleton.\"\"\" return _ALL_CONTAINERS.get(id(cls)) @classmethod def get(cls: type[_ContainerT], reload: bool = False) -> _ContainerT: \"\"\"Access method for the singleton.\"\"\" if (_the_container_or_none := cls._get()) is None or reload: # no config has been made yet or it needs to be reloaded, # so let's instantiate one and keep it in the global store _the_config = cls._create_instance() _the_config._set() else: _the_config = _the_container_or_none return _the_config @classmethod def update( cls: type[_ContainerT], changes: dict[str, dict[str, Any]] ) -> _ContainerT: \"Update and save the settings with data specified in changes; not meant for config\" return cls.get()._update(changes) # pylint: disable=protected-access def _update(self: _ContainerT, changes: dict[str, dict[str, Any]]) -> _ContainerT: \"Update and save the settings with data specified in changes; not meant for config\" # filter out fields that are both in changes and an attribute of the SettingsContainer _sections_to_update = { fld for fld in fields(self) if fld.init and fld.name in changes.keys() } # update the sections and keep them in a dict # actually sections: dict[str, _ContainerSectionT] # but MyPy doesn't swallow that updated_sections: dict[str, Any] = { fld.name: _update_section(getattr(self, fld.name), changes[fld.name]) for fld in _sections_to_update } new_settings = replace(self, **updated_sections) new_settings._set() # pylint: disable=protected-access new_settings._save() # pylint: disable=protected-access return new_settings @classmethod def _create_instance(cls: type[_ContainerT]) -> _ContainerT: \"\"\"Instantiate the Container.\"\"\" # get whatever is stored in the config/settings file data_stored = cls._get_stored_data() # filter out fields that are both stored and an attribute of the Container _data_fields = { fld for fld in fields(cls) if fld.init and fld.name in data_stored.keys() } # instantiate the sections and keep them in a dict # actually sections: dict[str, _ContainerSectionT] # but MyPy doesn't swallow that sections: dict[str, Any] = { fld.name: cls._instantiate_section(fld.type, data_stored[fld.name]) for fld in _data_fields } # instantiate the Container with the sections return cls(**sections) @classmethod def _get_stored_data(cls) -> dict[str, Any]: \"\"\"Get the data stored in the toml file\"\"\" data_stored: dict[str, Any] = {} if path := cls.filepath(): if (ext := path.suffix[1:].lower()) == str(FileFormat.TOML.value): with path.open(mode=\"rb\") as fptr: data_stored = tomllib.load(fptr) elif ext == str(FileFormat.JSON.value): with path.open(mode=\"r\") as fptr: data_stored = json.load(fptr) else: print(f\"Unknown file format {ext} given in {path}.\") else: # This situation can occur if no valid path was given as an argument, and # the default path is set to None. print( f\"No path specified for {cls.kind_string().lower()} file; trying with defaults, but this may not work.\" ) return data_stored @classmethod def _instantiate_section( cls: type[_ContainerT], class_to_instantiate: type[_ContainerSectionT], arg_dict: dict[str, Any], ) -> _ContainerSectionT: \"\"\"Return an instance of class_to_instantiate, properly initialized\"\"\" # pre-condition: class_to_instantiate is the class of an initializable field of cls assert ( len([f for f in fields(cls) if f.init and f.type == class_to_instantiate]) > 0 ) field_set = {f.name for f in fields(class_to_instantiate) if f.init} filtered_arg_dict = {k: v for k, v in arg_dict.items() if k in field_set} return class_to_instantiate(**filtered_arg_dict) def _set(self) -> None: \"\"\"Private method to store the singleton.\"\"\" _ALL_CONTAINERS[id(self.__class__)] = self def _save(self) -> None: \"\"\"Private method to save the singleton to file.\"\"\" if path := self.filepath(): path.parent.mkdir(parents=True, exist_ok=True) if (ext := path.suffix[1:].lower()) == FileFormat.TOML.value: with path.open(mode=\"wb\") as fptr: tomli_w.dump(asdict(self), fptr) elif ext == FileFormat.JSON.value: with path.open(mode=\"w\") as fptr: json.dump(asdict(self), fptr) else: print(f\"Unknown file format {ext} given in {path}.\") else: # This situation can occur if no valid path was given as an argument, and # the default path is set to None. raise RuntimeError( f\"No path specified for {self.kind_string().lower()} file, cannot be saved.\" ) def _update_section( section: _ContainerSectionT, changes: dict[str, Any] ) -> _ContainerSectionT: \"Update the settings section with data specified in changes; not meant for config\" # filter out fields that are both in changes and an attribute of the SettingsSection return replace(section, **changes) Variables ContainerTypeStr Classes ContainerBase class ContainerBase ( ) Base class for Config and Settings classes ??? example \"View Source\" @dataclass(frozen=True) class ContainerBase(ABC): \"\"\"Base class for Config and Settings classes\"\"\" @classmethod @abstractmethod def kind_string(cls: type[_ContainerT]) -> ContainerTypeStr: \"Return either 'Config' or 'Settings'\" @classmethod @abstractmethod def default_file_format(cls: type[_ContainerT]) -> FileFormat: \"Return the default file format\" @classmethod def default_foldername(cls: type[_ContainerT]) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" kind_str = cls.kind_string() return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() ) @classmethod def default_filename(cls: type[_ContainerT]) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\" @classmethod def default_filepath(cls: type[_ContainerT]) -> PathOpt: \"\"\"Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml\"\"\" return Path.home() / cls.default_foldername() / cls.default_filename() @classmethod def set_filepath(cls: type[_ContainerT], file_path: PathOrStr = \"\") -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath()) @classmethod def _get(cls: type[_ContainerT]) -> Optional[_ContainerT]: \"\"\"Private getter for the singleton.\"\"\" return _ALL_CONTAINERS.get(id(cls)) @classmethod def get(cls: type[_ContainerT], reload: bool = False) -> _ContainerT: \"\"\"Access method for the singleton.\"\"\" if (_the_container_or_none := cls._get()) is None or reload: # no config has been made yet or it needs to be reloaded, # so let's instantiate one and keep it in the global store _the_config = cls._create_instance() _the_config._set() else: _the_config = _the_container_or_none return _the_config @classmethod def update( cls: type[_ContainerT], changes: dict[str, dict[str, Any]] ) -> _ContainerT: \"Update and save the settings with data specified in changes; not meant for config\" return cls.get()._update(changes) # pylint: disable=protected-access def _update(self: _ContainerT, changes: dict[str, dict[str, Any]]) -> _ContainerT: \"Update and save the settings with data specified in changes; not meant for config\" # filter out fields that are both in changes and an attribute of the SettingsContainer _sections_to_update = { fld for fld in fields(self) if fld.init and fld.name in changes.keys() } # update the sections and keep them in a dict # actually sections: dict[str, _ContainerSectionT] # but MyPy doesn't swallow that updated_sections: dict[str, Any] = { fld.name: _update_section(getattr(self, fld.name), changes[fld.name]) for fld in _sections_to_update } new_settings = replace(self, **updated_sections) new_settings._set() # pylint: disable=protected-access new_settings._save() # pylint: disable=protected-access return new_settings @classmethod def _create_instance(cls: type[_ContainerT]) -> _ContainerT: \"\"\"Instantiate the Container.\"\"\" # get whatever is stored in the config/settings file data_stored = cls._get_stored_data() # filter out fields that are both stored and an attribute of the Container _data_fields = { fld for fld in fields(cls) if fld.init and fld.name in data_stored.keys() } # instantiate the sections and keep them in a dict # actually sections: dict[str, _ContainerSectionT] # but MyPy doesn't swallow that sections: dict[str, Any] = { fld.name: cls._instantiate_section(fld.type, data_stored[fld.name]) for fld in _data_fields } # instantiate the Container with the sections return cls(**sections) @classmethod def _get_stored_data(cls) -> dict[str, Any]: \"\"\"Get the data stored in the toml file\"\"\" data_stored: dict[str, Any] = {} if path := cls.filepath(): if (ext := path.suffix[1:].lower()) == str(FileFormat.TOML.value): with path.open(mode=\"rb\") as fptr: data_stored = tomllib.load(fptr) elif ext == str(FileFormat.JSON.value): with path.open(mode=\"r\") as fptr: data_stored = json.load(fptr) else: print(f\"Unknown file format {ext} given in {path}.\") else: # This situation can occur if no valid path was given as an argument, and # the default path is set to None. print( f\"No path specified for {cls.kind_string().lower()} file; trying with defaults, but this may not work.\" ) return data_stored @classmethod def _instantiate_section( cls: type[_ContainerT], class_to_instantiate: type[_ContainerSectionT], arg_dict: dict[str, Any], ) -> _ContainerSectionT: \"\"\"Return an instance of class_to_instantiate, properly initialized\"\"\" # pre-condition: class_to_instantiate is the class of an initializable field of cls assert ( len([f for f in fields(cls) if f.init and f.type == class_to_instantiate]) > 0 ) field_set = {f.name for f in fields(class_to_instantiate) if f.init} filtered_arg_dict = {k: v for k, v in arg_dict.items() if k in field_set} return class_to_instantiate(**filtered_arg_dict) def _set(self) -> None: \"\"\"Private method to store the singleton.\"\"\" _ALL_CONTAINERS[id(self.__class__)] = self def _save(self) -> None: \"\"\"Private method to save the singleton to file.\"\"\" if path := self.filepath(): path.parent.mkdir(parents=True, exist_ok=True) if (ext := path.suffix[1:].lower()) == FileFormat.TOML.value: with path.open(mode=\"wb\") as fptr: tomli_w.dump(asdict(self), fptr) elif ext == FileFormat.JSON.value: with path.open(mode=\"w\") as fptr: json.dump(asdict(self), fptr) else: print(f\"Unknown file format {ext} given in {path}.\") else: # This situation can occur if no valid path was given as an argument, and # the default path is set to None. raise RuntimeError( f\"No path specified for {self.kind_string().lower()} file, cannot be saved.\" ) Ancestors (in MRO) abc.ABC Descendants application_settings.configuring_base.ConfigBase application_settings.settings_base.SettingsBase Static methods default_file_format def default_file_format ( ) -> application_settings . container_base . FileFormat Return the default file format ??? example \"View Source\" @classmethod @abstractmethod def default_file_format(cls: type[_ContainerT]) -> FileFormat: \"Return the default file format\" default_filename def default_filename ( ) -> str Return the kind_string, lowercase, with the extension that fits the file_format. ??? example \"View Source\" @classmethod def default_filename(cls: type[_ContainerT]) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\" default_filepath def default_filepath ( ) -> pathlib . Path | None Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml ??? example \"View Source\" @classmethod def default_filepath(cls: type[_ContainerT]) -> PathOpt: \"\"\"Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml\"\"\" return Path.home() / cls.default_foldername() / cls.default_filename() default_foldername def default_foldername ( ) -> str Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words. ??? example \"View Source\" @classmethod def default_foldername(cls: type[_ContainerT]) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" kind_str = cls.kind_string() return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() ) filepath def filepath ( ) -> pathlib . Path | None Return the path for the file that holds the config / settings. ??? example \"View Source\" @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath()) get def get ( reload : bool = False ) -> ~ _ContainerT Access method for the singleton. ??? example \"View Source\" @classmethod def get(cls: type[_ContainerT], reload: bool = False) -> _ContainerT: \"\"\"Access method for the singleton.\"\"\" if (_the_container_or_none := cls._get()) is None or reload: # no config has been made yet or it needs to be reloaded, # so let's instantiate one and keep it in the global store _the_config = cls._create_instance() _the_config._set() else: _the_config = _the_container_or_none return _the_config kind_string def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return either 'Config' or 'Settings' ??? example \"View Source\" @classmethod @abstractmethod def kind_string(cls: type[_ContainerT]) -> ContainerTypeStr: \"Return either 'Config' or 'Settings'\" set_filepath def set_filepath ( file_path : pathlib . Path | str = '' ) -> None Set the path for the file (a singleton). ??? example \"View Source\" @classmethod def set_filepath(cls: type[_ContainerT], file_path: PathOrStr = \"\") -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) update def update ( changes : dict [ str , dict [ str , typing . Any ]] ) -> ~ _ContainerT Update and save the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update( cls: type[_ContainerT], changes: dict[str, dict[str, Any]] ) -> _ContainerT: \"Update and save the settings with data specified in changes; not meant for config\" return cls.get()._update(changes) # pylint: disable=protected-access ContainerSectionBase class ContainerSectionBase ( ) Base class for all ContainerSection classes (so that we can bound a TypeVar) ??? example \"View Source\" @dataclass(frozen=True) class ContainerSectionBase: \"\"\"Base class for all ContainerSection classes (so that we can bound a TypeVar)\"\"\" Descendants application_settings.configuring_base.ConfigSectionBase application_settings.settings_base.SettingsSectionBase FileFormat class FileFormat ( * args , ** kwds ) File formats that are supported ??? example \"View Source\" @unique class FileFormat(Enum): \"File formats that are supported\" TOML = \"toml\" JSON = \"json\" Ancestors (in MRO) enum.Enum Class variables JSON TOML name value","title":"Container Base"},{"location":"reference/application_settings/container_base/#module-application_settingscontainer_base","text":"Base classes for containers and sections for configuration and settings. ??? example \"View Source\" # pylint: disable=consider-alternative-union-syntax \"\"\"Base classes for containers and sections for configuration and settings.\"\"\" import json import sys from abc import ABC, abstractmethod from dataclasses import asdict, fields, replace from enum import Enum, unique from pathlib import Path from re import sub from typing import Any, Literal, Optional, TypeVar import tomli_w from pathvalidate import is_valid_filepath from pydantic.dataclasses import dataclass from .type_notation_helper import PathOpt, PathOrStr if sys.version_info >= (3, 11): import tomllib else: import tomli as tomllib _ContainerT = TypeVar(\"_ContainerT\", bound=\"ContainerBase\") _ContainerSectionT = TypeVar(\"_ContainerSectionT\", bound=\"ContainerSectionBase\") _ALL_CONTAINERS: dict[int, Any] = {} _ALL_PATHS: dict[int, PathOpt] = {} @unique class FileFormat(Enum): \"File formats that are supported\" TOML = \"toml\" JSON = \"json\" ContainerTypeStr = Literal[\"Config\", \"Settings\"] @dataclass(frozen=True) class ContainerSectionBase: \"\"\"Base class for all ContainerSection classes (so that we can bound a TypeVar)\"\"\" @dataclass(frozen=True) class ContainerBase(ABC): \"\"\"Base class for Config and Settings classes\"\"\" @classmethod @abstractmethod def kind_string(cls: type[_ContainerT]) -> ContainerTypeStr: \"Return either 'Config' or 'Settings'\" @classmethod @abstractmethod def default_file_format(cls: type[_ContainerT]) -> FileFormat: \"Return the default file format\" @classmethod def default_foldername(cls: type[_ContainerT]) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" kind_str = cls.kind_string() return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() ) @classmethod def default_filename(cls: type[_ContainerT]) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\" @classmethod def default_filepath(cls: type[_ContainerT]) -> PathOpt: \"\"\"Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml\"\"\" return Path.home() / cls.default_foldername() / cls.default_filename() @classmethod def set_filepath(cls: type[_ContainerT], file_path: PathOrStr = \"\") -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath()) @classmethod def _get(cls: type[_ContainerT]) -> Optional[_ContainerT]: \"\"\"Private getter for the singleton.\"\"\" return _ALL_CONTAINERS.get(id(cls)) @classmethod def get(cls: type[_ContainerT], reload: bool = False) -> _ContainerT: \"\"\"Access method for the singleton.\"\"\" if (_the_container_or_none := cls._get()) is None or reload: # no config has been made yet or it needs to be reloaded, # so let's instantiate one and keep it in the global store _the_config = cls._create_instance() _the_config._set() else: _the_config = _the_container_or_none return _the_config @classmethod def update( cls: type[_ContainerT], changes: dict[str, dict[str, Any]] ) -> _ContainerT: \"Update and save the settings with data specified in changes; not meant for config\" return cls.get()._update(changes) # pylint: disable=protected-access def _update(self: _ContainerT, changes: dict[str, dict[str, Any]]) -> _ContainerT: \"Update and save the settings with data specified in changes; not meant for config\" # filter out fields that are both in changes and an attribute of the SettingsContainer _sections_to_update = { fld for fld in fields(self) if fld.init and fld.name in changes.keys() } # update the sections and keep them in a dict # actually sections: dict[str, _ContainerSectionT] # but MyPy doesn't swallow that updated_sections: dict[str, Any] = { fld.name: _update_section(getattr(self, fld.name), changes[fld.name]) for fld in _sections_to_update } new_settings = replace(self, **updated_sections) new_settings._set() # pylint: disable=protected-access new_settings._save() # pylint: disable=protected-access return new_settings @classmethod def _create_instance(cls: type[_ContainerT]) -> _ContainerT: \"\"\"Instantiate the Container.\"\"\" # get whatever is stored in the config/settings file data_stored = cls._get_stored_data() # filter out fields that are both stored and an attribute of the Container _data_fields = { fld for fld in fields(cls) if fld.init and fld.name in data_stored.keys() } # instantiate the sections and keep them in a dict # actually sections: dict[str, _ContainerSectionT] # but MyPy doesn't swallow that sections: dict[str, Any] = { fld.name: cls._instantiate_section(fld.type, data_stored[fld.name]) for fld in _data_fields } # instantiate the Container with the sections return cls(**sections) @classmethod def _get_stored_data(cls) -> dict[str, Any]: \"\"\"Get the data stored in the toml file\"\"\" data_stored: dict[str, Any] = {} if path := cls.filepath(): if (ext := path.suffix[1:].lower()) == str(FileFormat.TOML.value): with path.open(mode=\"rb\") as fptr: data_stored = tomllib.load(fptr) elif ext == str(FileFormat.JSON.value): with path.open(mode=\"r\") as fptr: data_stored = json.load(fptr) else: print(f\"Unknown file format {ext} given in {path}.\") else: # This situation can occur if no valid path was given as an argument, and # the default path is set to None. print( f\"No path specified for {cls.kind_string().lower()} file; trying with defaults, but this may not work.\" ) return data_stored @classmethod def _instantiate_section( cls: type[_ContainerT], class_to_instantiate: type[_ContainerSectionT], arg_dict: dict[str, Any], ) -> _ContainerSectionT: \"\"\"Return an instance of class_to_instantiate, properly initialized\"\"\" # pre-condition: class_to_instantiate is the class of an initializable field of cls assert ( len([f for f in fields(cls) if f.init and f.type == class_to_instantiate]) > 0 ) field_set = {f.name for f in fields(class_to_instantiate) if f.init} filtered_arg_dict = {k: v for k, v in arg_dict.items() if k in field_set} return class_to_instantiate(**filtered_arg_dict) def _set(self) -> None: \"\"\"Private method to store the singleton.\"\"\" _ALL_CONTAINERS[id(self.__class__)] = self def _save(self) -> None: \"\"\"Private method to save the singleton to file.\"\"\" if path := self.filepath(): path.parent.mkdir(parents=True, exist_ok=True) if (ext := path.suffix[1:].lower()) == FileFormat.TOML.value: with path.open(mode=\"wb\") as fptr: tomli_w.dump(asdict(self), fptr) elif ext == FileFormat.JSON.value: with path.open(mode=\"w\") as fptr: json.dump(asdict(self), fptr) else: print(f\"Unknown file format {ext} given in {path}.\") else: # This situation can occur if no valid path was given as an argument, and # the default path is set to None. raise RuntimeError( f\"No path specified for {self.kind_string().lower()} file, cannot be saved.\" ) def _update_section( section: _ContainerSectionT, changes: dict[str, Any] ) -> _ContainerSectionT: \"Update the settings section with data specified in changes; not meant for config\" # filter out fields that are both in changes and an attribute of the SettingsSection return replace(section, **changes)","title":"Module application_settings.container_base"},{"location":"reference/application_settings/container_base/#variables","text":"ContainerTypeStr","title":"Variables"},{"location":"reference/application_settings/container_base/#classes","text":"","title":"Classes"},{"location":"reference/application_settings/container_base/#containerbase","text":"class ContainerBase ( ) Base class for Config and Settings classes ??? example \"View Source\" @dataclass(frozen=True) class ContainerBase(ABC): \"\"\"Base class for Config and Settings classes\"\"\" @classmethod @abstractmethod def kind_string(cls: type[_ContainerT]) -> ContainerTypeStr: \"Return either 'Config' or 'Settings'\" @classmethod @abstractmethod def default_file_format(cls: type[_ContainerT]) -> FileFormat: \"Return the default file format\" @classmethod def default_foldername(cls: type[_ContainerT]) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" kind_str = cls.kind_string() return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() ) @classmethod def default_filename(cls: type[_ContainerT]) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\" @classmethod def default_filepath(cls: type[_ContainerT]) -> PathOpt: \"\"\"Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml\"\"\" return Path.home() / cls.default_foldername() / cls.default_filename() @classmethod def set_filepath(cls: type[_ContainerT], file_path: PathOrStr = \"\") -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath()) @classmethod def _get(cls: type[_ContainerT]) -> Optional[_ContainerT]: \"\"\"Private getter for the singleton.\"\"\" return _ALL_CONTAINERS.get(id(cls)) @classmethod def get(cls: type[_ContainerT], reload: bool = False) -> _ContainerT: \"\"\"Access method for the singleton.\"\"\" if (_the_container_or_none := cls._get()) is None or reload: # no config has been made yet or it needs to be reloaded, # so let's instantiate one and keep it in the global store _the_config = cls._create_instance() _the_config._set() else: _the_config = _the_container_or_none return _the_config @classmethod def update( cls: type[_ContainerT], changes: dict[str, dict[str, Any]] ) -> _ContainerT: \"Update and save the settings with data specified in changes; not meant for config\" return cls.get()._update(changes) # pylint: disable=protected-access def _update(self: _ContainerT, changes: dict[str, dict[str, Any]]) -> _ContainerT: \"Update and save the settings with data specified in changes; not meant for config\" # filter out fields that are both in changes and an attribute of the SettingsContainer _sections_to_update = { fld for fld in fields(self) if fld.init and fld.name in changes.keys() } # update the sections and keep them in a dict # actually sections: dict[str, _ContainerSectionT] # but MyPy doesn't swallow that updated_sections: dict[str, Any] = { fld.name: _update_section(getattr(self, fld.name), changes[fld.name]) for fld in _sections_to_update } new_settings = replace(self, **updated_sections) new_settings._set() # pylint: disable=protected-access new_settings._save() # pylint: disable=protected-access return new_settings @classmethod def _create_instance(cls: type[_ContainerT]) -> _ContainerT: \"\"\"Instantiate the Container.\"\"\" # get whatever is stored in the config/settings file data_stored = cls._get_stored_data() # filter out fields that are both stored and an attribute of the Container _data_fields = { fld for fld in fields(cls) if fld.init and fld.name in data_stored.keys() } # instantiate the sections and keep them in a dict # actually sections: dict[str, _ContainerSectionT] # but MyPy doesn't swallow that sections: dict[str, Any] = { fld.name: cls._instantiate_section(fld.type, data_stored[fld.name]) for fld in _data_fields } # instantiate the Container with the sections return cls(**sections) @classmethod def _get_stored_data(cls) -> dict[str, Any]: \"\"\"Get the data stored in the toml file\"\"\" data_stored: dict[str, Any] = {} if path := cls.filepath(): if (ext := path.suffix[1:].lower()) == str(FileFormat.TOML.value): with path.open(mode=\"rb\") as fptr: data_stored = tomllib.load(fptr) elif ext == str(FileFormat.JSON.value): with path.open(mode=\"r\") as fptr: data_stored = json.load(fptr) else: print(f\"Unknown file format {ext} given in {path}.\") else: # This situation can occur if no valid path was given as an argument, and # the default path is set to None. print( f\"No path specified for {cls.kind_string().lower()} file; trying with defaults, but this may not work.\" ) return data_stored @classmethod def _instantiate_section( cls: type[_ContainerT], class_to_instantiate: type[_ContainerSectionT], arg_dict: dict[str, Any], ) -> _ContainerSectionT: \"\"\"Return an instance of class_to_instantiate, properly initialized\"\"\" # pre-condition: class_to_instantiate is the class of an initializable field of cls assert ( len([f for f in fields(cls) if f.init and f.type == class_to_instantiate]) > 0 ) field_set = {f.name for f in fields(class_to_instantiate) if f.init} filtered_arg_dict = {k: v for k, v in arg_dict.items() if k in field_set} return class_to_instantiate(**filtered_arg_dict) def _set(self) -> None: \"\"\"Private method to store the singleton.\"\"\" _ALL_CONTAINERS[id(self.__class__)] = self def _save(self) -> None: \"\"\"Private method to save the singleton to file.\"\"\" if path := self.filepath(): path.parent.mkdir(parents=True, exist_ok=True) if (ext := path.suffix[1:].lower()) == FileFormat.TOML.value: with path.open(mode=\"wb\") as fptr: tomli_w.dump(asdict(self), fptr) elif ext == FileFormat.JSON.value: with path.open(mode=\"w\") as fptr: json.dump(asdict(self), fptr) else: print(f\"Unknown file format {ext} given in {path}.\") else: # This situation can occur if no valid path was given as an argument, and # the default path is set to None. raise RuntimeError( f\"No path specified for {self.kind_string().lower()} file, cannot be saved.\" )","title":"ContainerBase"},{"location":"reference/application_settings/container_base/#ancestors-in-mro","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/application_settings/container_base/#descendants","text":"application_settings.configuring_base.ConfigBase application_settings.settings_base.SettingsBase","title":"Descendants"},{"location":"reference/application_settings/container_base/#static-methods","text":"","title":"Static methods"},{"location":"reference/application_settings/container_base/#default_file_format","text":"def default_file_format ( ) -> application_settings . container_base . FileFormat Return the default file format ??? example \"View Source\" @classmethod @abstractmethod def default_file_format(cls: type[_ContainerT]) -> FileFormat: \"Return the default file format\"","title":"default_file_format"},{"location":"reference/application_settings/container_base/#default_filename","text":"def default_filename ( ) -> str Return the kind_string, lowercase, with the extension that fits the file_format. ??? example \"View Source\" @classmethod def default_filename(cls: type[_ContainerT]) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\"","title":"default_filename"},{"location":"reference/application_settings/container_base/#default_filepath","text":"def default_filepath ( ) -> pathlib . Path | None Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml ??? example \"View Source\" @classmethod def default_filepath(cls: type[_ContainerT]) -> PathOpt: \"\"\"Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml\"\"\" return Path.home() / cls.default_foldername() / cls.default_filename()","title":"default_filepath"},{"location":"reference/application_settings/container_base/#default_foldername","text":"def default_foldername ( ) -> str Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words. ??? example \"View Source\" @classmethod def default_foldername(cls: type[_ContainerT]) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" kind_str = cls.kind_string() return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() )","title":"default_foldername"},{"location":"reference/application_settings/container_base/#filepath","text":"def filepath ( ) -> pathlib . Path | None Return the path for the file that holds the config / settings. ??? example \"View Source\" @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath())","title":"filepath"},{"location":"reference/application_settings/container_base/#get","text":"def get ( reload : bool = False ) -> ~ _ContainerT Access method for the singleton. ??? example \"View Source\" @classmethod def get(cls: type[_ContainerT], reload: bool = False) -> _ContainerT: \"\"\"Access method for the singleton.\"\"\" if (_the_container_or_none := cls._get()) is None or reload: # no config has been made yet or it needs to be reloaded, # so let's instantiate one and keep it in the global store _the_config = cls._create_instance() _the_config._set() else: _the_config = _the_container_or_none return _the_config","title":"get"},{"location":"reference/application_settings/container_base/#kind_string","text":"def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return either 'Config' or 'Settings' ??? example \"View Source\" @classmethod @abstractmethod def kind_string(cls: type[_ContainerT]) -> ContainerTypeStr: \"Return either 'Config' or 'Settings'\"","title":"kind_string"},{"location":"reference/application_settings/container_base/#set_filepath","text":"def set_filepath ( file_path : pathlib . Path | str = '' ) -> None Set the path for the file (a singleton). ??? example \"View Source\" @classmethod def set_filepath(cls: type[_ContainerT], file_path: PathOrStr = \"\") -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None)","title":"set_filepath"},{"location":"reference/application_settings/container_base/#update","text":"def update ( changes : dict [ str , dict [ str , typing . Any ]] ) -> ~ _ContainerT Update and save the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update( cls: type[_ContainerT], changes: dict[str, dict[str, Any]] ) -> _ContainerT: \"Update and save the settings with data specified in changes; not meant for config\" return cls.get()._update(changes) # pylint: disable=protected-access","title":"update"},{"location":"reference/application_settings/container_base/#containersectionbase","text":"class ContainerSectionBase ( ) Base class for all ContainerSection classes (so that we can bound a TypeVar) ??? example \"View Source\" @dataclass(frozen=True) class ContainerSectionBase: \"\"\"Base class for all ContainerSection classes (so that we can bound a TypeVar)\"\"\"","title":"ContainerSectionBase"},{"location":"reference/application_settings/container_base/#descendants_1","text":"application_settings.configuring_base.ConfigSectionBase application_settings.settings_base.SettingsSectionBase","title":"Descendants"},{"location":"reference/application_settings/container_base/#fileformat","text":"class FileFormat ( * args , ** kwds ) File formats that are supported ??? example \"View Source\" @unique class FileFormat(Enum): \"File formats that are supported\" TOML = \"toml\" JSON = \"json\"","title":"FileFormat"},{"location":"reference/application_settings/container_base/#ancestors-in-mro_1","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/application_settings/container_base/#class-variables","text":"JSON TOML name value","title":"Class variables"},{"location":"reference/application_settings/settings_base/","text":"Module application_settings.settings_base Module for handling settings. ??? example \"View Source\" \"\"\"Module for handling settings.\"\"\" from typing import TypeVar from pydantic.dataclasses import dataclass from .container_base import ( ContainerBase, ContainerSectionBase, ContainerTypeStr, FileFormat, ) SettingsT = TypeVar(\"SettingsT\", bound=\"SettingsBase\") SettingsSectionT = TypeVar(\"SettingsSectionT\", bound=\"SettingsSectionBase\") @dataclass(frozen=True) class SettingsSectionBase(ContainerSectionBase): \"\"\"Base class for all SettingsSection classes (so that we can bound a TypeVar)\"\"\" @dataclass(frozen=True) class SettingsBase(ContainerBase): \"\"\"Base class for main Settings class\"\"\" @classmethod def kind_string(cls: type[SettingsT]) -> ContainerTypeStr: \"Return 'Settings'\" return \"Settings\" @classmethod def default_file_format(cls: type[SettingsT]) -> FileFormat: \"Return the default file format\" return FileFormat.JSON Variables SettingsSectionT SettingsT Classes SettingsBase class SettingsBase ( ) Base class for main Settings class ??? example \"View Source\" @dataclass(frozen=True) class SettingsBase(ContainerBase): \"\"\"Base class for main Settings class\"\"\" @classmethod def kind_string(cls: type[SettingsT]) -> ContainerTypeStr: \"Return 'Settings'\" return \"Settings\" @classmethod def default_file_format(cls: type[SettingsT]) -> FileFormat: \"Return the default file format\" return FileFormat.JSON Ancestors (in MRO) application_settings.container_base.ContainerBase abc.ABC Static methods default_file_format def default_file_format ( ) -> application_settings . container_base . FileFormat Return the default file format ??? example \"View Source\" @classmethod def default_file_format(cls: type[SettingsT]) -> FileFormat: \"Return the default file format\" return FileFormat.JSON default_filename def default_filename ( ) -> str Return the kind_string, lowercase, with the extension that fits the file_format. ??? example \"View Source\" @classmethod def default_filename(cls: type[_ContainerT]) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\" default_filepath def default_filepath ( ) -> pathlib . Path | None Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml ??? example \"View Source\" @classmethod def default_filepath(cls: type[_ContainerT]) -> PathOpt: \"\"\"Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml\"\"\" return Path.home() / cls.default_foldername() / cls.default_filename() default_foldername def default_foldername ( ) -> str Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words. ??? example \"View Source\" @classmethod def default_foldername(cls: type[_ContainerT]) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" kind_str = cls.kind_string() return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() ) filepath def filepath ( ) -> pathlib . Path | None Return the path for the file that holds the config / settings. ??? example \"View Source\" @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath()) get def get ( reload : bool = False ) -> ~ _ContainerT Access method for the singleton. ??? example \"View Source\" @classmethod def get(cls: type[_ContainerT], reload: bool = False) -> _ContainerT: \"\"\"Access method for the singleton.\"\"\" if (_the_container_or_none := cls._get()) is None or reload: # no config has been made yet or it needs to be reloaded, # so let's instantiate one and keep it in the global store _the_config = cls._create_instance() _the_config._set() else: _the_config = _the_container_or_none return _the_config kind_string def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Settings' ??? example \"View Source\" @classmethod def kind_string(cls: type[SettingsT]) -> ContainerTypeStr: \"Return 'Settings'\" return \"Settings\" set_filepath def set_filepath ( file_path : pathlib . Path | str = '' ) -> None Set the path for the file (a singleton). ??? example \"View Source\" @classmethod def set_filepath(cls: type[_ContainerT], file_path: PathOrStr = \"\") -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None) update def update ( changes : dict [ str , dict [ str , typing . Any ]] ) -> ~ _ContainerT Update and save the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update( cls: type[_ContainerT], changes: dict[str, dict[str, Any]] ) -> _ContainerT: \"Update and save the settings with data specified in changes; not meant for config\" return cls.get()._update(changes) # pylint: disable=protected-access SettingsSectionBase class SettingsSectionBase ( ) Base class for all SettingsSection classes (so that we can bound a TypeVar) ??? example \"View Source\" @dataclass(frozen=True) class SettingsSectionBase(ContainerSectionBase): \"\"\"Base class for all SettingsSection classes (so that we can bound a TypeVar)\"\"\" Ancestors (in MRO) application_settings.container_base.ContainerSectionBase","title":"Settings Base"},{"location":"reference/application_settings/settings_base/#module-application_settingssettings_base","text":"Module for handling settings. ??? example \"View Source\" \"\"\"Module for handling settings.\"\"\" from typing import TypeVar from pydantic.dataclasses import dataclass from .container_base import ( ContainerBase, ContainerSectionBase, ContainerTypeStr, FileFormat, ) SettingsT = TypeVar(\"SettingsT\", bound=\"SettingsBase\") SettingsSectionT = TypeVar(\"SettingsSectionT\", bound=\"SettingsSectionBase\") @dataclass(frozen=True) class SettingsSectionBase(ContainerSectionBase): \"\"\"Base class for all SettingsSection classes (so that we can bound a TypeVar)\"\"\" @dataclass(frozen=True) class SettingsBase(ContainerBase): \"\"\"Base class for main Settings class\"\"\" @classmethod def kind_string(cls: type[SettingsT]) -> ContainerTypeStr: \"Return 'Settings'\" return \"Settings\" @classmethod def default_file_format(cls: type[SettingsT]) -> FileFormat: \"Return the default file format\" return FileFormat.JSON","title":"Module application_settings.settings_base"},{"location":"reference/application_settings/settings_base/#variables","text":"SettingsSectionT SettingsT","title":"Variables"},{"location":"reference/application_settings/settings_base/#classes","text":"","title":"Classes"},{"location":"reference/application_settings/settings_base/#settingsbase","text":"class SettingsBase ( ) Base class for main Settings class ??? example \"View Source\" @dataclass(frozen=True) class SettingsBase(ContainerBase): \"\"\"Base class for main Settings class\"\"\" @classmethod def kind_string(cls: type[SettingsT]) -> ContainerTypeStr: \"Return 'Settings'\" return \"Settings\" @classmethod def default_file_format(cls: type[SettingsT]) -> FileFormat: \"Return the default file format\" return FileFormat.JSON","title":"SettingsBase"},{"location":"reference/application_settings/settings_base/#ancestors-in-mro","text":"application_settings.container_base.ContainerBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/application_settings/settings_base/#static-methods","text":"","title":"Static methods"},{"location":"reference/application_settings/settings_base/#default_file_format","text":"def default_file_format ( ) -> application_settings . container_base . FileFormat Return the default file format ??? example \"View Source\" @classmethod def default_file_format(cls: type[SettingsT]) -> FileFormat: \"Return the default file format\" return FileFormat.JSON","title":"default_file_format"},{"location":"reference/application_settings/settings_base/#default_filename","text":"def default_filename ( ) -> str Return the kind_string, lowercase, with the extension that fits the file_format. ??? example \"View Source\" @classmethod def default_filename(cls: type[_ContainerT]) -> str: \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\" return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\"","title":"default_filename"},{"location":"reference/application_settings/settings_base/#default_filepath","text":"def default_filepath ( ) -> pathlib . Path | None Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml ??? example \"View Source\" @classmethod def default_filepath(cls: type[_ContainerT]) -> PathOpt: \"\"\"Return the fully qualified path for the config/settingsfile: e.g. ~/.example/config.toml\"\"\" return Path.home() / cls.default_foldername() / cls.default_filename()","title":"default_filepath"},{"location":"reference/application_settings/settings_base/#default_foldername","text":"def default_foldername ( ) -> str Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words. ??? example \"View Source\" @classmethod def default_foldername(cls: type[_ContainerT]) -> str: \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\" kind_str = cls.kind_string() return ( \".\" + sub(\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower() )","title":"default_foldername"},{"location":"reference/application_settings/settings_base/#filepath","text":"def filepath ( ) -> pathlib . Path | None Return the path for the file that holds the config / settings. ??? example \"View Source\" @classmethod def filepath(cls) -> PathOpt: \"\"\"Return the path for the file that holds the config / settings.\"\"\" return _ALL_PATHS.get(id(cls), cls.default_filepath())","title":"filepath"},{"location":"reference/application_settings/settings_base/#get","text":"def get ( reload : bool = False ) -> ~ _ContainerT Access method for the singleton. ??? example \"View Source\" @classmethod def get(cls: type[_ContainerT], reload: bool = False) -> _ContainerT: \"\"\"Access method for the singleton.\"\"\" if (_the_container_or_none := cls._get()) is None or reload: # no config has been made yet or it needs to be reloaded, # so let's instantiate one and keep it in the global store _the_config = cls._create_instance() _the_config._set() else: _the_config = _the_container_or_none return _the_config","title":"get"},{"location":"reference/application_settings/settings_base/#kind_string","text":"def kind_string ( ) -> Literal [ 'Config' , 'Settings' ] Return 'Settings' ??? example \"View Source\" @classmethod def kind_string(cls: type[SettingsT]) -> ContainerTypeStr: \"Return 'Settings'\" return \"Settings\"","title":"kind_string"},{"location":"reference/application_settings/settings_base/#set_filepath","text":"def set_filepath ( file_path : pathlib . Path | str = '' ) -> None Set the path for the file (a singleton). ??? example \"View Source\" @classmethod def set_filepath(cls: type[_ContainerT], file_path: PathOrStr = \"\") -> None: \"\"\"Set the path for the file (a singleton).\"\"\" path: PathOpt = None if isinstance(file_path, Path): path = file_path.resolve() elif file_path: if is_valid_filepath(file_path, platform=\"auto\"): path = Path(file_path).resolve() else: raise ValueError( f\"Given path: '{file_path}' is not a valid path for this OS\" ) if path: _ALL_PATHS[id(cls)] = path else: _ALL_PATHS.pop(id(cls), None)","title":"set_filepath"},{"location":"reference/application_settings/settings_base/#update","text":"def update ( changes : dict [ str , dict [ str , typing . Any ]] ) -> ~ _ContainerT Update and save the settings with data specified in changes; not meant for config ??? example \"View Source\" @classmethod def update( cls: type[_ContainerT], changes: dict[str, dict[str, Any]] ) -> _ContainerT: \"Update and save the settings with data specified in changes; not meant for config\" return cls.get()._update(changes) # pylint: disable=protected-access","title":"update"},{"location":"reference/application_settings/settings_base/#settingssectionbase","text":"class SettingsSectionBase ( ) Base class for all SettingsSection classes (so that we can bound a TypeVar) ??? example \"View Source\" @dataclass(frozen=True) class SettingsSectionBase(ContainerSectionBase): \"\"\"Base class for all SettingsSection classes (so that we can bound a TypeVar)\"\"\"","title":"SettingsSectionBase"},{"location":"reference/application_settings/settings_base/#ancestors-in-mro_1","text":"application_settings.container_base.ContainerSectionBase","title":"Ancestors (in MRO)"},{"location":"reference/application_settings/type_notation_helper/","text":"Module application_settings.type_notation_helper Defines type aliasses that handle notational differences between python versions. ??? example \"View Source\" # pylint: disable=consider-alternative-union-syntax \"\"\"Defines type aliasses that handle notational differences between python versions.\"\"\" import sys from pathlib import Path if sys.version_info >= (3, 10): from typing import TypeAlias PathOrStr: TypeAlias = Path | str PathOpt: TypeAlias = Path | None else: from typing import Optional, Union from typing_extensions import TypeAlias PathOrStr: TypeAlias = Union[Path, str] PathOpt: TypeAlias = Optional[Path]","title":"Type Notation Helper"},{"location":"reference/application_settings/type_notation_helper/#module-application_settingstype_notation_helper","text":"Defines type aliasses that handle notational differences between python versions. ??? example \"View Source\" # pylint: disable=consider-alternative-union-syntax \"\"\"Defines type aliasses that handle notational differences between python versions.\"\"\" import sys from pathlib import Path if sys.version_info >= (3, 10): from typing import TypeAlias PathOrStr: TypeAlias = Path | str PathOpt: TypeAlias = Path | None else: from typing import Optional, Union from typing_extensions import TypeAlias PathOrStr: TypeAlias = Union[Path, str] PathOpt: TypeAlias = Optional[Path]","title":"Module application_settings.type_notation_helper"}]}